出版者的话前言第1章　引论11.1　本书讨论的内容11.2　数学知识复习21.2.1　指数21.2.2　对数21.2.3　级数21.2.4　模运算41.2.5　证明的方法41.3　递归简论51.4　实现泛型构件pre-Java 571.4.1　使用Object表示泛型81.4.2　基本类型的包装91.4.3　使用接口类型表示泛型91.4.4　数组类型的兼容性101.5　利用Java 5泛型特性实现泛型构件111.5.1　简单的泛型类和接口111.5.2　自动装箱/拆箱111.5.3　菱形运算符121.5.4　带有限制的通配符121.5.5　泛型static方法141.5.6　类型限界141.5.7　类型擦除151.5.8　对于泛型的限制151.6　函数对象16小结18练习18参考文献19第2章　算法分析202.1　数学基础202.2　模型222.3　要分析的问题222.4　运行时间计算242.4.1　一个简单的例子242.4.2　一般法则242.4.3　最大子序列和问题的求解262.4.4　运行时间中的对数312.4.5　分析结果的准确性33小结33练习34参考文献37第3章　表、栈和队列393.1　抽象数据类型393.2　表ADT393.2.1　表的简单数组实现403.2.2　简单链表403.3　Java Collections API中的表413.3.1　Collection接口413.3.2　Iterator接口423.3.3　List接口、ArrayList类和LinkedList类433.3.4　例子：remove方法对LinkedList类的使用443.3.5　关于ListIterator接口463.4　ArrayList类的实现463.4.1　基本类463.4.2　迭代器、Java嵌套类和内部类493.5　LinkedList类的实现523.6　栈ADT583.6.1　栈模型583.6.2　栈的实现593.6.3　应用593.7　队列ADT653.7.1　队列模型653.7.2　队列的数组实现653.7.3　队列的应用66小结67练习67第4章　树714.1　预备知识714.1.1　树的实现724.1.2　树的遍历及应用724.2　二叉树754.2.1　实现764.2.2　例子：表达式树764.3　查找树ADT——二叉查找树784.3.1　contains方法794.3.2　findMin方法和findMax方法804.3.3　insert方法804.3.4　remove方法824.3.5　平均情况分析834.4　AVL树864.4.1　单旋转874.4.2　双旋转894.5　伸展树944.5.1　一个简单的想法（不能直接使用）954.5.2　展开964.6　再探树的遍历1004.7　B树1014.8　标准库中的集合与映射1054.8.1　关于Set接口1054.8.2　关于Map接口1054.8.3　TreeSet类和TreeMap类的实现1064.8.4　使用多个映射的实例106小结111练习111参考文献115第5章　散列1175.1　一般想法1175.2　散列函数1175.3　分离链接法1195.4　不用链表的散列表1235.4.1　线性探测法1235.4.2　平方探测法1245.4.3　双散列1295.5　再散列1305.6　标准库中的散列表1325.7　最坏情形下O(1)访问的散列表 1335.7.1　完美散列1335.7.2　布谷鸟散列1355.7.3　跳房子散列1435.8　通用散列法1465.9　可扩散列148小结149练习150参考文献153第6章　优先队列（堆）1566.1　模型1566.2　一些简单的实现1566.3　二叉堆1576.3.1　结构性质1576.3.2　堆序性质1576.3.3　基本的堆操作1586.3.4　其他的堆操作1626.4　优先队列的应用1646.4.1　选择问题1646.4.2　事件模拟1656.5　d-堆1666.6　左式堆1676.6.1　左式堆性质1676.6.2　左式堆操作1686.7　斜堆1726.8　二项队列1736.8.1　二项队列结构1746.8.2　二项队列操作1746.8.3　二项队列的实现1766.9　标准库中的优先队列180小结180练习181参考文献184第7章　排序1867.1　预备知识1867.2　插入排序1867.2.1　算法1867.2.2　插入排序的分析1877.3　一些简单排序算法的下界1877.4　希尔排序1887.5　堆排序1917.6　归并排序1937.7　快速排序1987.7.1　选取枢纽元1997.7.2　分割策略2007.7.3　小数组2027.7.4　实际的快速排序例程2027.7.5　快速排序的分析2037.7.6　选择问题的线性期望时间算法2067.8　排序算法的一般下界2077.9　选择问题的决策树下界2097.10　对手下界2107.11　线性时间的排序：桶排序和基数排序2127.12　外部排序2167.12.1　为什么需要一些新的算法2177.12.2　外部排序模型2177.12.3　简单算法2177.12.4　多路合并2187.12.5　多相合并2197.12.6　替换选择219小结220练习221参考文献225第8章　不相交集类2278.1　等价关系2278.2　动态等价性问题2278.3　基本数据结构2298.4　灵巧求并算法2318.5　路径压缩2338.6　路径压缩和按秩求并的最坏情形2348.6.1　缓慢增长的函数2358.6.2　利用递归分解的分析2358.6.3　O(M log*N)界2408.6.4　O(Mα(M,N))界2408.7　一个应用241小结243练习243参考文献244第9章　图论算法2469.1　若干定义2469.2　拓扑排序2489.3　最短路径算法2509.3.1　无权最短路径2519.3.2　Dijkstra算法2549.3.3　具有负边值的图2589.3.4　无圈图2599.3.5　所有点对最短路径2619.3.6　最短路径的例子2619.4　网络流问题2629.5　最小生成树2679.5.1　Prim算法2679.5.2　Kruskal算法2699.6　深度优先搜索的应用2709.6.1　无向图2709.6.2　双连通性2719.6.3　欧拉回路2739.6.4　有向图2759.6.5　查找强分支2769.7　NP-完全性介绍2779.7.1　难与易2789.7.2　NP类2789.7.3　NP-完全问题279小结280练习280参考文献284第10章　算法设计技巧28810.1　贪婪算法28810.1.1　一个简单的调度问题28810.1.2　哈夫曼编码29010.1.3　近似装箱问题29310.2　分治算法29810.2.1　分治算法的运行时间29810.2.2　最近点问题30010.2.3　选择问题30210.2.4　一些算术问题的理论改进30410.3　动态规划30710.3.1　用一个表代替递归30710.3.2　矩阵乘法的顺序安排30910.3.3　最优二叉查找树31110.3.4　所有点对最短路径31210.4　随机化算法31410.4.1　随机数发生器31510.4.2　跳跃表31910.4.3　素性测试32010.5　回溯算法32210.5.1　收费公路重建问题32310.5.2　博弈326小结331练习331参考文献336第11章　摊还分析34011.1　一个无关的智力问题34011.2　二项队列34011.3　斜堆34411.4　斐波那契堆34511.4.1　切除左式堆中的节点34611.4.2　二项队列的懒惰合并34711.4.3　斐波那契堆操作34911.4.4　时间界的证明35011.5　伸展树351小结354练习354参考文献355第12章　高级数据结构及其实现35612.1　自顶向下伸展树35612.2　红黑树36212.2.1　自底向上的插入36212.2.2　自顶向下红黑树36312.2.3　自顶向下的删除36712.3　treap树36812.4　后缀数组与后缀树37012.4.1　后缀数组37112.4.2　后缀树37312.4.3　线性时间的后缀数组和后缀树的构建37512.5　k-d树38512.6　配对堆387小结392练习393参考文献396索引399 显示全部信息