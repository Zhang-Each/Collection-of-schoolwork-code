第1章 Java性能调优概述 1.1 性能概述 1.1.1 看懂程序的性能 1.1.2 性能的参考指标 1.1.3 木桶原理与性能瓶颈 1.1.4 Amdahl定律 1.2 性能调优的层次 1.2.1 设计调优 1.2.2 代码调优 1.2.3 JVM调优 1.2.4 数据库调优 1.2.5 操作系统调优 1.3 基本调优策略和手段 1.3.1 优化的一般步骤 第1章 Java性能调优概述1.1 性能概述1.1.1 看懂程序的性能1.1.2 性能的参考指标1.1.3 木桶原理与性能瓶颈1.1.4 Amdahl定律1.2 性能调优的层次1.2.1 设计调优1.2.2 代码调优1.2.3 JVM调优1.2.4 数据库调优1.2.5 操作系统调优1.3 基本调优策略和手段1.3.1 优化的一般步骤1.3.2 系统优化注意事项1.4 小结第2章 设计优化2.1 善用设计模式2.1.1 单例模式2.1.2 代理模式2.1.3 享元模式2.1.4 装饰者模式2.1.5 观察者模式2.1.6 Value Object模式2.1.7 业务代理模式2.2 常用优化组件和方法2.2.1 缓冲（Buffer）2.2.2 缓存（Cache）2.2.3 对象复用——“池”2.2.4 并行替代串行2.2.5 负载均衡2.2.6 时间换空间2.2.7 空间换时间2.3 小结第3章 Java程序优化3.1 字符串优化处理3.1.1 String对象及其特点3.1.2 subString()方法的内存泄漏3.1.3 字符串分割和查找3.1.4 StringBuffer和StringBuilder3.2 核心数据结构3.2.1 List接口3.2.2 Map接口3.2.3 Set接口3.2.4 优化集合访问代码3.2.5 RandomAccess接口3.3 使用NIO提升性能3.3.1 NIO的Buffer类族和Channel3.3.2 Buffer的基本原理3.3.3 Buffer的相关操作3.3.4 MappedByteBuffer性能评估3.3.5 直接内存访问3.4 引用类型3.4.1 强引用3.4.2 软引用3.4.3 弱引用3.4.4 虚引用3.4.5 WeakHashMap类及其实现3.5 有助于改善性能的技巧3.5.1 慎用异常3.5.2 使用局部变量3.5.3 位运算代替乘除法3.5.4 替换switch3.5.5 一维数组代替二维数组3.5.6 提取表达式3.5.7 展开循环3.5.8 布尔运算代替位运算3.5.9 使用arrayCopy ()3.5.10 使用Buffer进行I/O操作3.5.11 使用clone()代替new3.5.12 静态方法替代实例方法3.6 小结第4章 并行程序开发及优化4.1 并行程序设计模式4.1.1 Future模式4.1.2 Master-Worker模式4.1.3 Guarded Suspension模式4.1.4 不变模式4.1.5 生产者-消费者模式4.2 JDK多任务执行框架4.2.1 无限制线程的缺陷4.2.2 简单的线程池实现4.2.3 Executor框架4.2.4 自定义线程池4.2.5 优化线程池大小4.2.6 扩展ThreadPoolExecutor4.3 JDK并发数据结构4.3.1 并发List4.3.2 并发Set4.3.3 并发Map4.3.4 并发Queue4.3.5 并发Deque4.4 并发控制方法4.4.1 Java内存模型与volatile4.4.2 同步关键字synchronized4.4.3 ReentrantLock重入锁4.4.4 ReadWriteLock读写锁4.4.5 Condition对象4.4.6 Semaphore信号量4.4.7 ThreadLocal线程局部变量4.5 “锁”的性能和优化4.5.1 线程的开销4.5.2 避免死锁4.5.3 减小锁持有时间4.5.4 减小锁粒度4.5.5 读写分离锁来替换独占锁4.5.6 锁分离4.5.7 重入锁ReentrantLock和内部锁synchronized4.5.8 锁粗化(Lock Coarsening)4.5.9 自旋锁（Spinning Lock）4.5.10 锁消除（Lock Elimination）4.5.11 锁偏向(Biased Lock)4.6 无锁的并行计算4.6.1 非阻塞的同步/无锁4.6.2 原子操作4.6.3 Amino框架介绍4.6.4 Amino集合4.6.5 Amino树4.6.6 Amino图4.6.7 Amino简单调度模式4.7 协程4.7.1 协程的概念4.7.2 Kilim框架简介4.7.3 Task及其状态4.7.4 Fiber及其状态4.7.5 Kilim开发环境配置4.7.6 Kilim之Hello World4.7.7 多任务通信4.7.8 Kilim实例及性能评估4.8 小结第5章 JVM调优5.1 Java虚拟机内存模型5.1.1 程序计数器5.1.2 Java虚拟机栈5.1.3 本地方法栈5.1.4 Java堆5.1.5 方法区5.2 JVM内存分配参数5.2.1 设置最大堆内存5.2.2 设置最小堆内存5.2.3 设置新生代5.2.4 设置持久代5.2.5 设置线程桟5.2.6 堆的比例分配5.2.7 堆分配参数总结5.3 垃圾收集基础5.3.1 垃圾收集的作用5.3.2 垃圾回收算法与思想5.3.3 垃圾收集器的类型5.3.4 评价GC策略的指标5.3.5 新生代串行收集器5.3.6 老年代串行收集器5.3.7 并行收集器5.3.8 新生代并行回收（Parallel Scavenge）收集器5.3.9 老年代并行回收收集器5.3.10 CMS收集器5.3.11 G1收集器（Garbage First）5.3.12 Stop the World案例5.3.13 收集器对系统性能的影响5.3.14 GC相关参数总结5.4 常用调优案例和方法5.4.1 将新对象预留在新生代5.4.2 大对象进入老年代5.4.3 设置对象进入老年代的年龄5.4.4 稳定与震荡的堆大小5.4.5 吞吐量优先案例5.4.6 使用大页案例5.4.7 降低停顿案例5.5 实用JVM参数5.5.1 JIT编译参数5.5.2 堆快照（堆Dump）5.5.3 错误处理5.5.4 取得GC信息5.5.5 类和对象跟踪5.5.6 控制GC5.5.7 选择类校验器5.5.8 Solaris下线程控制5.5.9 使用大页5.5.10 压缩指针5.6 实战JVM调优5.6.1 Tomcat简介与启动加速5.6.2 Web应用程序介绍5.6.3 JMeter介绍与使用5.6.4 调优前Web应用运行状况5.6.5 调优过程5.7 总结第6章 Java性能调优工具6.1 Linux命令行工具6.1.1 top命令6.1.2 sar命令6.1.3 vmstat命令6.1.4 iostat命令6.1.5 pidstat工具6.2 Windows工具6.2.1 任务管理器6.2.2 perfmon性能监控工具6.2.3 Process Explorer6.2.4 pslist命令行6.3 JDK命令行工具6.3.1 jps命令6.3.2 jstat命令6.3.3 jinfo命令6.3.4 jmap命令6.3.5 jhat命令6.3.6 jstack命令6.3.7 jstatd命令6.3.8 hprof工具6.4 JConsole工具6.4.1 JConsole连接Java程序6.4.2 Java程序概况6.4.3 内存监控6.4.4 线程监控6.4.5 类加载情况6.4.6 虚拟机信息6.4.7 MBean管理6.4.8 使用插件6.5 Visual VM多合一工具6.5.1 Visual VM连接应用程序6.5.2 监控应用程序概况6.5.3 Thread Dump和分析6.5.4 性能分析6.5.5 快照6.5.6 内存快照分析6.5.7 MBean管理6.5.8 TDA使用6.5.9 BTrace介绍6.6 Visual VM对OQL的支持6.6.1 Visual VM的OQL基本语法6.6.2 内置heap对象6.6.3 对象函数6.6.4 集合/统计函数6.6.5 程序化OQL6.7 MAT内存分析工具6.7.1 初识MAT6.7.2 浅堆和深堆6.7.3 支配树（Dominator Tree）6.7.4 垃圾回收根6.7.5 内存泄露检测6.7.6 最大对象报告6.7.7 查找支配者6.7.8 线程分析6.7.9 集合使用情况分析6.7.10 扩展MAT6.8 MAT对OQL的支持6.8.1 Select子句6.8.2 From子句6.8.3 Where子句6.8.4 内置对象与方法6.9 JProfile简介6.9.1 JProfile使用配置6.9.2 内存视图6.9.3 堆快照6.9.4 CPU视图6.9.5 线程视图6.9.6 JVM统计信息6.9.7 触发器6.10 小结 显示全部信息