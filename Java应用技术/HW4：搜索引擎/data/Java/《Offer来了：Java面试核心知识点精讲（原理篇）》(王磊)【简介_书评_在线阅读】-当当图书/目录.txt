第1章 JVM 1 1.1 JVM的运行机制 1 1.2 多线程 2 1.3 JVM的内存区域 3 1.3.1 程序计数器：线程私有，无内存溢出问题 4 1.3.2 虚拟机栈：线程私有，描述Java方法的执行过程 4 1.3.3 本地方法区：线程私有 5 1.3.4 堆：也叫作运行时数据区，线程共享 5 1.3.5 方法区：线程共享 5 1.4 JVM的运行时内存 6 1.4.1 新生代：Eden区、ServivorTo区和ServivorFrom区 7 1.4.2 老年代 8 1.4.3 永久代 8 1.5 垃圾回收与算法 9 
第1章 JVM 1 
1.1 JVM的运行机制 1 
1.2 多线程 2 
1.3 JVM的内存区域 3 
1.3.1 程序计数器：线程私有，无内存溢出问题 4 
1.3.2 虚拟机栈：线程私有，描述Java方法的执行过程 4 
1.3.3 本地方法区：线程私有 5 
1.3.4 堆：也叫作运行时数据区，线程共享 5 
1.3.5 方法区：线程共享 5 
1.4 JVM的运行时内存 6 
1.4.1 新生代：Eden区、ServivorTo区和ServivorFrom区 7 
1.4.2 老年代 8 
1.4.3 永久代 8 
1.5 垃圾回收与算法 9 
1.5.1 如何确定垃圾 9 
1.5.2 Java中常用的垃圾回收算法 10 
1.6 Java中的4种引用类型 13 
1.7 分代收集算法和分区收集算法 14 
1.7.1 分代收集算法 14 
1.7.2 分区收集算法 15 
1.8 垃圾收集器 15 
1.8.1 Serial垃圾收集器：单线程，复制算法 16 
1.8.2 ParNew垃圾收集器：多线程，复制算法 16 
1.8.3 Parallel Scavenge垃圾收集器：多线程，复制算法 16 
1.8.4 Serial Old垃圾收集器：单线程，标记整理算法 16 
1.8.5 Parallel Old垃圾收集器：多线程，标记整理算法 17 
1.8.6 CMS垃圾收集器 18 
1.8.7 G1垃圾收集器 18 
1.9 Java网络编程模型 19 
1.9.1 阻塞I/O模型 19 
1.9.2 非阻塞I/O模型 19 
1.9.3 多路复用I/O模型 20 
1.9.4 信号驱动I/O模型 21 
1.9.5 异步I/O模型 21 
1.9.6 Java I/O 21 
1.9.7 Java NIO 22 
1.10 JVM的类加载机制 28 
1.10.1 JVM的类加载阶段 28 
1.10.2 类加载器 29 
1.10.3 双亲委派机制 30 
1.10.4 OSGI 32 
第2章 Java基础 33 
2.1 集合 33 
2.1.1 List：可重复 34 
2.1.2 Queue 34 
2.1.3 Set：不可重复 35 
2.1.4 Map 36 
2.2 异常分类及处理 39 
2.2.1 异常的概念 39 
2.2.2 异常分类 40 
2.2.3 异常处理方式：抛出异常、使用try catch捕获并处理异常 41 
2.3 反射机制 42 
2.3.1 动态语言的概念 42 
2.3.2 反射机制的概念 43 
2.3.3 反射的应用 43 
2.3.4 Java的反射API 43 
2.3.5 反射的步骤 43 
2.3.6 创建对象的两种方式 45 
2.3.7 Method的invoke方法 45 
2.4 注解 46 
2.4.1 注解的概念 46 
2.4.2 标准元注解：@Target、@Retention、@Documented、@Inherited 46 
2.4.3 注解处理器 47 
2.5 内部类 49 
2.5.1 静态内部类 49 
2.5.2 成员内部类 50 
2.5.3 局部内部类 51 
2.5.4 匿名内部类 51 
2.6 泛型 52 
2.6.1 泛型标记和泛型限定：E、T、K、V、N、? 53 
2.6.2 泛型方法 53 
2.6.3 泛型类 54 
2.6.4 泛型接口 55 
2.6.5 类型擦除 56 
2.7 序列化 56 
2.7.1 Java序列化API的使用 57 
2.7.2 序列化和反序列化 58 
第3章 Java并发编程 59 
3.1 Java线程的创建方式 59 
3.1.1 继承Thread类 59 
3.1.2 实现Runnable接口 60 
3.1.3 通过ExecutorService和Callable＜Class＞实现有返回值的线程 61 
3.1.4 基于线程池 62 
3.2 线程池的工作原理 62 
3.2.1 线程复用 63 
3.2.2 线程池的核心组件和核心类 63 
3.2.3 Java线程池的工作流程 65 
3.2.4 线程池的拒绝策略 66 
3.3 5种常用的线程池 68 
3.3.1 newCachedThreadPool 68 
3.3.2 newFixedThreadPool 68 
3.3.3 newScheduledThreadPool 69 
3.3.4 newSingleThreadExecutor 69 
3.3.5 newWorkStealingPool 69 
3.4 线程的生命周期 70 
3.4.1 新建状态：New 71 
3.4.2 就绪状态：Runnable 71 
3.4.3 运行状态：Running 71 
3.4.4 阻塞状态：Blocked 71 
3.4.5 线程死亡：Dead 72 
3.5 线程的基本方法 72 
3.5.1 线程等待：wait方法 72 
3.5.2 线程睡眠：sleep方法 73 
3.5.3 线程让步：yield方法 73 
3.5.4 线程中断：interrupt方法 73 
3.5.5 线程加入：join方法 74 
3.5.6 线程唤醒：notify方法 75 
3.5.7 后台守护线程：setDaemon方法 75 
3.5.8 sleep方法与wait方法的区别 76 
3.5.9 start方法与run方法的区别 76 
3.5.10 终止线程的4种方式 77 
3.6 Java中的锁 79 
3.6.1 乐观锁 79 
3.6.2 悲观锁 79 
3.6.3 自旋锁 80 
3.6.4 synchronized 81 
3.6.5 ReentrantLock 89 
3.6.6 synchronized和ReentrantLock的比较 94 
3.6.7 Semaphore 95 
3.6.8 AtomicInteger 96 
3.6.9 可重入锁 97 
3.6.10 公平锁与非公平锁 97 
3.6.11 读写锁：ReadWriteLock 98 
3.6.12 共享锁和独占锁 98 
3.6.13 重量级锁和轻量级锁 99 
3.6.14 偏向锁 99 
3.6.15 分段锁 100 
3.6.16 同步锁与死锁 100 
3.6.17 如何进行锁优化 100 
3.7 线程上下文切换 101 
3.7.1 上下文切换 102 
3.7.2 引起线程上下文切换的原因 102 
3.8 Java阻塞队列 103 
3.8.1 阻塞队列的主要操作 104 
3.8.2 Java中的阻塞队列实现 108 
3.9 Java并发关键字 113 
3.9.1 CountDownLatch 113 
3.9.2 CyclicBarrier 114 
3.9.3 Semaphore 116 
3.9.4 volatile关键字的作用 117 
3.10 多线程如何共享数据 119 
3.10.1 将数据抽象成一个类，并将对这个数据的操作封装在类的方法中 119 
3.10.2 将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量 121 
3.11 ConcurrentHashMap并发 122 
3.11.1 减小锁粒度 122 
3.11.2 ConcurrentHashMap的实现 123 
3.12 Java中的线程调度 123 
3.12.1 抢占式调度 123 
3.12.2 协同式调度 124 
3.12.3 Java线程调度的实现：抢占式 124 
3.12.4 线程让出CPU的情况 125 
3.13 进程调度算法 125 
3.13.1 优先调度算法 125 
3.13.2 高优先权优先调度算法 126 
3.13.3 时间片的轮转调度算法 127 
3.14 什么是CAS 128 
3.14.1 CAS的概念：比较并交换 128 
3.14.2 CAS的特性：乐观锁 128 
3.14.3 CAS自旋等待 129 
3.15 ABA问题 129 
3.16 什么是AQS 130 
3.16.1 AQS的原理 130 
3.16.2 state：状态 131 
3.16.3 AQS共享资源的方式：独占式和共享式 131 
第4章 数据结构 133 
4.1 栈及其Java实现 133 
4.2 队列及其Java实现 136 
4.3 链表 138 
4.3.1 链表的特点 139 
4.3.2 单向链表的操作及其Java实现 139 
4.3.3 双向链表及其Java实现 143 
4.3.4 循环链表 146 
4.4 散列表 146 
4.4.1 常用的构造散列函数 147 
4.4.2 Hash的应用 148 
4.5 二叉排序树 148 
4.5.1 插入操作 149 
4.5.2 删除操作 149 
4.5.3 查找操作 151 
4.5.4 用Java实现二叉排序树 151 
4.6 红黑树 155 
4.6.1 红黑树的特性 156 
4.6.2 红黑树的左旋 156 
4.6.3 红黑树的右旋 157 
4.6.4 红黑树的添加 157 
4.6.5 红黑树的删除 158 
4.7 图 159 
4.7.1 无向图和有向图 159 
4.7.2 图的存储结构：邻接矩阵 160 
4.7.3 图的存储结构：邻接表 161 
4.7.4 图的遍历 162 
4.8 位图 164 
4.8.1 位图的数据结构 164 
4.8.2 位图的Java实现 165 
第5章 Java中的常用算法 167 
5.1 二分查找算法 167 
5.1.1 二分查找算法的原理 168 
5.1.2 二分查找算法的Java实现 168 
5.2 冒泡排序算法 169 
5.2.1 冒泡排序算法的原理 169 
5.2.2 冒泡排序算法的Java实现 170 
5.3 插入排序算法 171 
5.3.1 插入排序算法的原理 171 
5.3.2 插入排序算法的Java实现 172 
5.4 快速排序算法 173 
5.4.1 快速排序算法的原理 173 
5.4.2 快速排序算法的Java实现 174 
5.5 希尔排序算法 175 
5.5.1 希尔排序算法的原理 176 
5.5.2 希尔排序算法的Java实现 177 
5.6 归并排序算法 178 
5.6.1 归并排序算法的原理 178 
5.6.2 归并排序算法的Java实现 178 
5.7 桶排序算法 180 
5.7.1 桶排序算法的原理 180 
5.7.2 桶排序算法的Java实现 181 
5.8 基数排序算法 182 
5.8.1 基数排序算法的原理 182 
5.8.2 基数排序算法的Java实现 183 
5.9 其他算法 184 
5.9.1 剪枝算法 184 
5.9.2 回溯算法 186 
5.9.3 最短路径算法 186 
第6章 网络与负载均衡 188 
6.1 网络 188 
6.1.1 OSI七层网络模型 188 
6.1.2 TCP/IP四层网络模型 189 
6.1.3 TCP三次握手/四次挥手 190 
6.1.4 HTTP的原理 195 
6.1.5 CDN的原理 199 
6.2 负载均衡 201 
6.2.1 四层负载均衡与七层负载均衡的对比 201 
6.2.2 负载均衡算法 203 
6.2.3 LVS的原理及应用 205 
6.2.4 Nginx反向代理与负载均衡 211 
第7章 数据库及分布式事务 214 
7.1 数据库的基本概念及原则 214 
7.1.1 存储引擎 214 
7.1.2 创建索引的原则 216 
7.1.3 数据库三范式 217 
7.1.4 数据库事务 218 
7.1.5 存储过程 219 
7.1.6 触发器 219 
7.2 数据库的并发操作和锁 220 
7.2.1 数据库的并发策略 220 
7.2.2 数据库锁 220 
7.2.3 数据库分表 223 
7.3 数据库分布式事务 223 
7.3.1 CAP 223 
7.3.2 两阶段提交协议 224 
7.3.3 三阶段提交协议 225 
7.3.4 分布式事务 227 
第8章 分布式缓存的原理及应用 230 
8.1 分布式缓存介绍 230 
8.2 Ehcache的原理及应用 231 
8.2.1 Ehcache的原理 231 
8.2.2 Ehcache的应用 234 
8.3 Redis的原理及应用 235 
8.3.1 Redis的原理 235 
8.
 显示全部信息