前言 第1章并发编程的挑战 1.1上下文切换 1.1.1多线程一定快吗 1.1.2测试上下文切换次数和时长 1.1.3如何减少上下文切换 1.1.4减少上下文切换实战 1.2死锁 1.3资源限制的挑战 1.4本章小结 第2章Java并发机制的底层实现原理 2.1volatile的应用 2.2synchronized的实现原理与应用 2.2.1Java对象头 前言第1章并发编程的挑战1.1上下文切换1.1.1多线程一定快吗1.1.2测试上下文切换次数和时长1.1.3如何减少上下文切换1.1.4减少上下文切换实战1.2死锁1.3资源限制的挑战1.4本章小结
第2章Java并发机制的底层实现原理2.1volatile的应用2.2synchronized的实现原理与应用2.2.1Java对象头2.2.2锁的升级与对比2.3原子操作的实现原理2.4本章小结
第3章Java内存模型3.1Java内存模型的基础3.1.1并发编程模型的两个关键问题3.1.2Java内存模型的抽象结构3.1.3从源代码到指令序列的重排序3.1.4并发编程模型的分类3.1.5happensbefore简介3.2重排序3.2.1数据依赖性3.2.2asifserial语义3.2.3程序顺序规则3.2.4重排序对多线程的影响3.3顺序一致性3.3.1数据竞争与顺序一致性3.3.2顺序一致性内存模型3.3.3同步程序的顺序一致性效果3.3.4未同步程序的执行特性3.4volatile的内存语义3.4.1volatile的特性3.4.2volatile写读建立的happensbefore关系3.4.3volatile写读的内存语义3.4.4volatile内存语义的实现3.4.5JSR133为什么要增强volatile的内存语义3.5锁的内存语义3.5.1锁的释放获取建立的happensbefore关系3.5.2锁的释放和获取的内存语义3.5.3锁内存语义的实现3.5.4concurrent包的实现3.6final域的内存语义3.6.1final域的重排序规则3.6.2写final域的重排序规则3.6.3读final域的重排序规则3.6.4final域为引用类型3.6.5为什么final引用不能从构造函数内"溢出"3.6.6final语义在处理器中的实现3.6.7JSR133为什么要增强f?inal的语义3.7happensbefore3.7.1JMM的设计3.7.2happensbefore的定义3.7.3happensbefore规则3.8双重检查锁定与延迟初始化3.8.1双重检查锁定的由来3.8.2问题的根源3.8.3基于volatile的解决方案3.8.4基于类初始化的解决方案3.9Java内存模型综述3.9.1处理器的内存模型3.9.2各种内存模型之间的关系3.9.3JMM的内存可见性保证3.9.4JSR133对旧内存模型的修补3.10本章小结
第4章Java并发编程基础4.1线程简介4.1.1什么是线程4.1.2为什么要使用多线程4.1.3线程优先级4.1.4线程的状态4.1.5Daemon线程4.2启动和终止线程4.2.1构造线程4.2.2启动线程4.2.3理解中断4.2.4过期的suspend()、resume()和stop()4.2.5安全地终止线程4.3线程间通信4.3.1volatile和synchronized关键字4.3.2等待/通知机制4.3.3等待/通知的经典范式4.3.4管道输入/输出流4.3.5Thread.join()的使用4.3.6ThreadLocal的使用4.4线程应用实例4.4.1等待超时模式4.4.2一个简单的数据库连接池示例4.4.3线程池技术及其示例4.4.4一个基于线程池技术的简单Web服务器4.5本章小结
第5章Java中的锁5.1Lock接口5.2队列同步器5.2.1队列同步器的接口与示例5.2.2队列同步器的实现分析5.3重入锁5.4读写锁5.4.1读写锁的接口与示例5.4.2读写锁的实现分析5.5LockSupport工具5.6Condition接口5.6.1Condition接口与示例5.6.2Condition的实现分析5.7本章小结
第6章Java并发容器和框架6.1ConcurrentHashMap的实现原理与使用6.1.1为什么要使用ConcurrentHashMap6.1.2ConcurrentHashMap的结构6.1.3ConcurrentHashMap的初始化6.1.4定位Segment6.1.5ConcurrentHashMap的操作6.2ConcurrentLinkedQueue6.2.1ConcurrentLinkedQueue的结构6.2.2入队列6.2.3出队列6.3Java中的阻塞队列6.3.1什么是阻塞队列6.3.2Java里的阻塞队列6.3.3阻塞队列的实现原理6.4Fork/Join框架6.4.1什么是Fork/Join框架6.4.2工作窃取算法6.4.3Fork/Join框架的设计6.4.4使用Fork/Join框架6.4.5Fork/Join框架的异常处理6.4.6Fork/Join框架的实现原理6.5本章小结
第7章Java中的13个原子操作类7.1原子更新基本类型类7.2原子更新数组7.3原子更新引用类型7.4原子更新字段类7.5本章小结
第8章Java中的并发工具类8.1等待多线程完成的CountDownLatch8.2同步屏障CyclicBarrier8.2.1CyclicBarrier简介8.2.2CyclicBarrier的应用场景8.2.3CyclicBarrier和CountDownLatch的区别8.3控制并发线程数的Semaphore8.4线程间交换数据的Exchanger8.5本章小结
第9章Java中的线程池9.1线程池的实现原理9.2线程池的使用9.2.1线程池的创建9.2.2向线程池提交任务9.2.3关闭线程池9.2.4合理地配置线程池9.2.5线程池的监控9.3本章小结
第10章Executor框架10.1Executor框架简介10.1.1Executor框架的两级调度模型10.1.2Executor框架的结构与成员10.2ThreadPoolExecutor详解10.2.1FixedThreadPool详解10.2.2SingleThreadExecutor详解10.2.3CachedThreadPool详解10.3ScheduledThreadPoolExecutor详解10.3.1ScheduledThreadPoolExecutor的运行机制10.3.2ScheduledThreadPoolExecutor的实现10.4FutureTask详解10.4.1FutureTask简介10.4.2FutureTask的使用10.4.3FutureTask的实现10.5本章小结
第11章Java并发编程实践11.1生产者和消费者模式11.1.1生产者消费者模式实战11.1.2多生产者和多消费者场景11.1.3线程池与生产消费者模式11.2线上问题定位11.3性能测试11.4异步任务池11.5本章小结 显示全部信息