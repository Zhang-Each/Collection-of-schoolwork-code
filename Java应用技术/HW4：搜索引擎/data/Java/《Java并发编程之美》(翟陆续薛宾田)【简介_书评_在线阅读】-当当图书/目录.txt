第一部分 Java 并发编程基础篇 第1章并发编程线程基础 2 1.1 什么是线程 2 1.2 线程创建与运行 3 1.3 线程通知与等待 6 1.4 等待线程执行终止的join 方法 16 1.5 让线程睡眠的sleep 方法 19 1.6 让出CPU 执行权的yield 方法 23 1.7 线程中断 24 1.8 理解线程上下文切换 30 1.9 线程死锁 30 1.9.1 什么是线程死锁 30 1.9.2 如何避免线程死锁 33 1.10 守护线程与用户线程 35 
第一部分
 Java 并发编程基础篇

第1章
并发编程线程基础  2

1.1  什么是线程  2

1.2  线程创建与运行  3

1.3  线程通知与等待  6

1.4  等待线程执行终止的join 方法  16

1.5  让线程睡眠的sleep 方法  19

1.6  让出CPU 执行权的yield 方法
 23

1.7  线程中断  24

1.8  理解线程上下文切换  30

1.9  线程死锁  30

1.9.1  什么是线程死锁
 30

1.9.2  如何避免线程死锁
 33

1.10  守护线程与用户线程  35

1.11
 ThreadLocal  39

1.11.1
 ThreadLocal 使用示例  40

1.11.2
 ThreadLocal 的实现原理  42

1.11.3
 ThreadLocal 不支持继承性  45

1.11.4
 InheritableThreadLocal 类  46

第2章  并发编程的其他基础知识  50

2.1  什么是多线程并发编程  50

2.2  为什么要进行多线程并发编程  51

2.3  Java 中的线程安全问题  51

?2.4  Java 中共享变量的内存可见性问题  52

2.5  Java 中的synchronized 关键字  54

2.5.1
 synchronized 关键字介绍  54

2.5.2
 synchronized 的内存语义  55

2.6  Java 中的volatile 关键字  55

2.7  Java 中的原子性操作  57

2.8  Java 中的CAS 操作  59

2.9  Unsafe 类  59

2.9.1  Unsafe 类中的重要方法  59

2.9.2  如何使用Unsafe 类  61

2.10  Java 指令重排序  65

2.11  伪共享  67

2.11.1  什么是伪共享  67

2.11.2  为何会出现伪共享  68

2.11.3  如何避免伪共享  70

2.11.4  小结  72

2.12  锁的概述  72

2.12.1  乐观锁与悲观锁  72

2.12.2  公平锁与非公平锁  75

2.12.3  独占锁与共享锁  75

2.12.4  什么是可重入锁  76

2.12.5  自旋锁  77

2.13  总结  77

第二部分
 Java 并发编程高级篇

第3章  Java 并发包中ThreadLocalRandom 类原理剖析  80

3.1  Random 类及其局限性  80

3.2
 ThreadLocalRandom  82

3.3  源码分析  84

3.4  总结  87

第4 章  Java 并发包中原子操作类原理剖析  88

4.1  原子变量操作类  88

4.2  JDK 8 新增的原子操作类LongAdder  93

4.2.1
 LongAdder 简单介绍  93

4.2.2
 LongAdder 代码分析  95

4.2.3  小结  101

4.3
 LongAccumulator 类原理探究  102

4.4  总结  104

第5章  Java 并发包中并发List 源码剖析  105

5.1  介绍  105

5.2  主要方法源码解析  106

5.2.1  初始化  106

5.2.2  添加元素  106

5.2.3  获取指定位置元素  108

5.2.4  修改指定元素  109

5.2.5  删除元素  110

5.2.6  弱一致性的迭代器  111

5.3  总结  114

第6章  Java 并发包中锁原理剖析  115

6.1
 LockSupport 工具类  115

6.2  抽象同步队列AQS 概述  122

6.2.1  AQS——锁的底层支持  122

6.2.2  AQS——条件变量的支持  128

6.2.3  基于AQS 实现自定义同步器  131

6.3  独占锁ReentrantLock 的原理  136

6.3.1  类图结构  136

6.3.2  获取锁  137

6.3.3  释放锁  142

6.3.4  案例介绍  143

6.3.5  小结  145

?6.4  读写锁ReentrantReadWriteLock 的原理  145

6.4.1  类图结构  145

6.4.2  写锁的获取与释放  147

6.4.3  读锁的获取与释放  151

6.4.4  案例介绍  156

6.4.5  小结  158

6.5  JDK 8 中新增的StampedLock 锁探究  158

6.5.1  概述  158

6.5.2  案例介绍  160

6.5.3  小结  164

第7章  Java 并发包中并发队列原理剖析  165

7.1
 ConcurrentLinkedQueue 原理探究  165

7.1.1  类图结构  165

7.1.2
 ConcurrentLinkedQueue 原理介绍  166

7.1.3  小结  181

7.2
 LinkedBlockingQueue 原理探究  182

7.2.1  类图结构  182

7.2.2
 LinkedBlockingQueue 原理介绍  185

7.2.3  小结  194

7.3
 ArrayBlockingQueue 原理探究  195

7.3.1  类图结构  195

7.3.2
 ArrayBlockingQueue 原理介绍  197

7.3.3  小结  202

7.4
 PriorityBlockingQueue 原理探究  203

7.4.1  介绍  203

7.4.2
 PriorityBlockingQueue 类图结构  203

7.4.3  原理介绍  205

7.4.4  案例介绍  214

7.4.5  小结  216

7.5  DelayQueue
原理探究  217

7.5.1
 DelayQueue 类图结构  217

7.5.2  主要函数原理讲解  219

7.5.3  案例介绍  222

7.5.4  小结  224

第8章  Java 并发包中线程池ThreadPoolExecutor 原理探究  225

8.1  介绍  225

8.2  类图介绍  225

8.3  源码分析  230

8.3.1  public
void execute(Runnable command)  230

8.3.2  工作线程Worker 的执行  235

8.3.3  shutdown
操作  238

8.3.4
 shutdownNow 操作  240

8.3.5
 awaitTermination 操作  241

8.4  总结  242

第9章  Java 并发包中ScheduledThreadPoolExecutor 原理探究  243

9.1  介绍  243

9.2  类图介绍  243

9.3  原理剖析  245

9.3.1
 schedule(Runnable command, long delay,TimeUnit unit) 方法  246

9.3.2
 scheduleWithFixedDelay(Runnable command,long initialDelay, long
delay,TimeUnit unit) 方法  252

9.3.3
 scheduleAtFixedRate(Runnable command,long initialDelay,long
period,TimeUnit unit) 方法  254

9.4  总结  255

第10章  Java 并发包中线程同步器原理剖析  256

10.1  CountDownLatch
原理剖析  256

10.1.1  案例介绍  256

10.1.2  实现原理探究  259

10.1.3  小结  263

10.2  回环屏障CyclicBarrier 原理探究  264

10.2.1  案例介绍  264

10.2.2  实现原理探究  268

10.2.3  小结  272

?10.3  信号量Semaphore 原理探究  272

10.3.1  案例介绍  272

10.3.2  实现原理探究  276

10.3.3  小结  281

10.4  总结  281

第三部分
 Java 并发编程实践篇

第11章  并发编程实践  284

11.1
 ArrayBlockingQueue 的使用  284

11.1.1  异步日志打印模型概述  284

11.1.2  异步日志与具体实现  285

11.1.3  小结  293

11.2  Tomcat 的NioEndPoint 中ConcurrentLinkedQueue 的使用  293

11.2.1  生产者——Acceptor 线程  294

11.2.2  消费者——Poller 线程  298

11.2.3  小结  300

11.3  并发组件ConcurrentHashMap 使用注意事项  300

11.4
 SimpleDateFormat 是线程不安全的  304

11.4.1  问题复现  304

11.4.2  问题分析  305

11.4.3  小结  309

11.5  使用Timer 时需要注意的事情  309

11.5.1  问题的产生  309

11.5.2  Timer 实现原理分析  310

11.5.3  小结  313

11.6  对需要复用但是会被下游修改的参数要进行深复制  314

11.6.1  问题的产生  314

11.6.2  问题分析  316

11.6.3  小结  318

11.7  创建线程和线程池时要指定与业务相关的名称  319

11.7.1  创建线程需要有线程名  319

11.7.2  创建线程池时也需要指定线程池的名称  321

11.7.3  小结  325

11.8  使用线程池的情况下当程序结束时记得调用shutdown 关闭线程池  325

11.8.1  问题复现  325

11.8.2  问题分析  327

11.8.3  小结  329

11.9  线程池使用FutureTask 时需要注意的事情  329

11.9.1  问题复现  329

11.9.2  问题分析  332

11.9.3  小结  335

11.10  使用ThreadLocal 不当可能会导致内存泄漏  336

11.10.1  为何会出现内存泄漏  336

11.10.2  在线程池中使用ThreadLocal 导致的内存泄漏  339

11.10.3  在Tomcat 的Servlet 中使用ThreadLocal
导致内存泄漏  341

11.10.4  小结  344

11.11  总结  344
 显示全部信息