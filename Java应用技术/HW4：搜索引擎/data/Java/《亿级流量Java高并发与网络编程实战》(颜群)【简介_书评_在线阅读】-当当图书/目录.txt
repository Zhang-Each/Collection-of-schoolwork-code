目录 1.1 大型系统的技术基石—高并发 2 1.2 高并发技术的市场需求与从业者的薪资水平 2 1.3 本书阅读建议 4 2.1 系统分析原则—如何从全局掌控一个大型系统 6 2.1.1　高并发原则 6 2.1.2　容错原则 6 2.1.3　CAP原则 7 2.1.4　幂等性原则 7 2.1.5　可扩展原则 8 2.1.6　可维护原则与可监控原则 9 2.2 系统设计要点：在设计阶段提前规避问题 10 2.2.1　Session共享问题 10 2.2.2　优先考虑无状态服务 11 
目录

  第1章  高并发概述 1
1.1     大型系统的技术基石—高并发 2
1.2     高并发技术的市场需求与从业者的薪资水平 2
1.3     本书阅读建议 4

  第2章  系统分析与大型互联网架构设计 5
2.1     系统分析原则—如何从全局掌控一个大型系统 6
2.1.1　高并发原则 6
2.1.2　容错原则 6
2.1.3　CAP原则 7
2.1.4　幂等性原则 7
2.1.5　可扩展原则 8
2.1.6　可维护原则与可监控原则 9
2.2     系统设计要点：在设计阶段提前规避问题 10
2.2.1　Session共享问题 10
2.2.2　优先考虑无状态服务 11
2.2.3　技术选型原则与数据库设计 12
2.2.4　缓存穿透与缓存雪崩问题 13
2.2.5　综合因素 14
2.3     大型系统的演进 15
2.3.1　不同类型的服务器 15
2.3.2　集群服务与动静分离 15
2.3.3　分布式系统 15
2.3.4　提高数据的访问性能 16
2.3.5　跨语言RPC整合 16
2.4     大型系统架构设计 16
2.4.1　服务预处理—限流与多层负载 17
2.4.2　各组件的技术选型建议 18
2.5     分布式ID生成器 19

  第3章  高并发相关JVM与JDK新特性案例讲解 21
3.1     JVM核心概念及JVM对高并发的支持 22
3.1.1　内存区域与内存模型 22
3.1.2　使用volatile解决可见性与重排序问题 24
3.2     Java对同步机制的解决方案及案例解析 27
3.2.1　使用synchronized解决并发售票问题与死锁演示 27
3.2.2　使用线程通信、队列及线程池模拟生产消费者场景 31
3.2.3　使用Lock重构生产消费者及线程通信 39
3.2.4　CAS无锁算法 46
3.2.5　使用信号量（Semaphor）实现线程通信 47
3.3     不可不学的Java新特性 48
3.3.1　Lambda及函数式接口实例讲解 48
3.3.2　5种形式的方法引用演示案例 53
3.3.3　通过案例详解Stream流式处理的生成、转换与终端操作 57

  第4章  实战解析多线程并发包 63
4.1     JUC核心类的深度解析与使用案例 64
4.1.1　使用CopyOnWrite实现并发写操作 64
4.1.2　使用ReadWriteLock实现读写锁 67
4.1.3　ConcurrentHashMap的底层结构与演进过程 69
4.1.4　使用BlockingQueue实现排序和定时任务 71
4.1.5　通过CountDownLatch实现多线程闭锁 77
4.1.6　使用CyclicBarrier在多线程中设置屏障 79
4.1.7　使用FutureTask和Callable实现多线程 80
4.2     通过源码掌握并发包的基石AQS 83
4.2.1　AQS原理解析 84
4.2.2　AQS源码解读 86
4.2.3　独占模式源码解读 88
4.3     实战线程池 95
4.3.1　5种类型线程池的创建方式 95
4.3.2　常用线程池的应用示例与解析 97
4.3.3　自定义线程池的构建原理与案例详解 100
4.4     通过CompletableFuture控制线程间依赖关系的案例解析 106       
4.5     异步模型和事件驱动模型 109
   
第5章   分布式网络编程核心技术—远程调用 111
5.1     OSI与TCP/IP网络模型 112
5.1.1　OSI七层参考模型 112
5.1.2　TCP/IP四层模型 114
5.2     实战远程调用的设计模式—代理模式 115
5.2.1　租房代理商—静态代理 115
5.2.2　万能代理商—动态代理 117
5.3     使用网络编程实现分布式远程调用 120
5.3.1　远程调用两大方案—RMI与RPC 120
5.3.2　综合案例：通过底层技能实现RMI 121

 第6章   NIO案例解析与高性能聊天室实战 123
6.1     阻塞式数据传输—I/O核心思想与文件传输案例 124
6.1.1　I/O设计的核心思想：装饰模式 124
6.1.2　I/O应用案例：远程传输文件 126
6.2     非阻塞式数据传输—NIO详解与案例演示 128
6.2.1　NIO数据存储结构：缓冲区Buffer 129
6.2.2　缓冲区的搬运工：通道Channel 132
6.2.3　通过零拷贝实现高性能文件传输 135
6.2.4　规范读写的工具：管道Pipe 144
6.2.5　结合选择器Selector开发高性能聊天室 144
6.3     异步非阻塞式数据传输—AIO的两种实现方式 153
6.4     编码解码 160
6.4.1　编码解码原理及历史问题 160
6.4.2　编码解码操作案例 161
 

 第7章  高性能NIO框架Netty实例详解 163
7.1     Netty快速入门 164
7.1.1　Netty核心概念 164
7.1.2　使用Gradle搭建Netty开发环境 164
7.2     使用Netty开发基于BS架构的网络编程案例 166
7.2.1　Netty编写流程与服务端开发案例 166
7.2.2　使用Netty开发点对点通信与聊天室功能 173
7.3     使用Netty远程传输文件 182
7.4     Netty经典使用场景与实现案例 188
7.4.1　使用Netty实现心跳检测机制 188
7.4.2　使用Netty实现基于CS架构的WebSocket通信 189
7.5     使用Netty和Protobuf实现RPC功能 193
7.5.1　Google Protocol Buffer环境搭建与使用案例 193
7.5.2　使用Netty Protobuf开发自定义RPC功能 196
 

第8章   主流RPC框架解析与跨语言调用案例 205
8.1     Apache Thrift 206
8.1.1　Apache Thrift从入门到实践 206
8.1.2　使用Thrift实现Java、NodeJS、Python之间的跨语言RPC调用 211     　　
8.2     Google gRPC 219
8.2.1　Google gRPC从入门到动手实践 219
8.2.2　使用gRPC实现Java、NodeJS、Python之间的跨语言RPC调用 236         
8.3     Hadoop RPC案例演示 240
 

 第9章  实战解析高并发框架Disruptor 243
9.1     Disruptor理论基石：观察者模式 244
9.1.1　自己动手实现观察者模式 244
9.1.2　JDK对观察者模式的支持 247
9.2     Disruptor原理解析与典型案例 247
9.2.1　Disruptor核心概念 248
9.2.2　使用Disruptor在200ms内处理千万字符 249
9.2.3　使用Disruptor轻松实现复杂的依赖逻辑 255
9.3     通过案例讲解RingBuffer的两种使用方式 261
9.3.1　EventHandler BatchEventProcessor使用案例 262
9.3.2　WorkerPool WorkHandler使用案例 266
9.4     Disruptor底层组件解析 272
9.4.1　SequenceBarrier原理精讲 273
9.4.2　Sequencer核心概念 273
  

第10章 手把手开发微服务构建框架Spring Boot 275
10.1   微服务简介与Spring Boot入门案例 276
10.1.1　微服务简介 276
10.1.2　从环境搭建到开发第一个Spring Boot微服务 277
10.1.3　Spring Boot CLI快速体验 279
10.2   从源码角度深度解析Spring Boot核心要点 280
10.2.1　使用Starter快速导入依赖并解决版本冲突问题 280
10.2.2　Spring Boot自动装配机制的源码解读 285
10.2.3　Spring Boot中依赖的加载时机及检测方法 293
10.3   通过案例详解Spring Boot配置文件 297
10.3.1　配置文件Properties与YAML 297
10.3.2　使用YAML文件注入各种类型数据 298
10.3.3　使用Properties文件注入数据 303
10.3.4　使用@Value()注入数据以及各种注入方式的区别演示 304
10.3.5　多环境配置的切换 308
10.3.6　内外配置文件和动态参数的设置 311
10.4   使用Spring Boot开发Web项目 314
10.4.1　从源码角度分析静态资源的存放路径 314
10.4.2　根据源码自定义设置欢迎页 317
10.4.3　根据源码设置favicon.ico和自定义静态资源路径 319
10.4.4　Thymeleaf核心语法和与Spring Boot的整合案例 321
10.4.5　通过外置Tomcat整合JSP并实现文件上传 326
 

 
第11章 Spring全家桶—使用Spring Boot整合常见Web组件 331
              
11.1   Spring Boot整合日志框架 332
11.1.1　在Spring Boot中使用日志 332
11.1.2　通过案例演示日志的个性化设置 333
11.2   Spring Boot访问数据库 336
11.2.1　Spring Boot操作JDBC案例与数据源的装配源码解读 336
11.2.2　通过DRUID演示自定义数据源的使用 341
11.2.3　SQL初始化源码解读与自动化脚本实践 343
11.2.4　使用Spring Boot轻松处理事务 346
11.3   基于Spring Boot的SSM整合开发 347
11.3.1　Spring Boot整合SSM完整案例 347
11.3.2　第三方配置文件的引入与自定义配置类 351
11.4   Spring Boot整合第三方组件 355
11.4.1　Spring Boot整合FastJson 355
11.4.2　通过源码和案例详解Spring Boot缓存 357
11.4.3　使用Spring Boot Redis实现分布式Session 376
11.4.4　Docker入门及实战 377
11.4.5　Spring Boot整合消息队列的案例详解 381
11.4.6　使用Spring Boot整合HttpClient访问网络资源 389
11.4.7　通过案例讲解Spring Boot整合异步及计划任务 395
 

 第12章 微服务治理框架Spring Cloud理论与案例解析 399
12.1   Spring Cloud要点精讲及入门案例 400
12.1.1　微服务架构 400
12.1.2　从零开始搭建基于生产消费模型的Spring Cloud案例 401
12.2   通过案例详解微服务注册中心Eureka 415
12.2.1　使用Eureka统一管理服务的提供者与消费者 415
12.2.2　Eureka服务发现案例演示 421
12.2.3　动手搭建Eureka集群 423
12.3   实战Spring Cloud中的负载均衡组件 425
12.3.1　客户端负载均衡工具Ribbon使用案例 425
12.3.2　声明式负载均衡工具Feign使用案例 431
12.3.3　使用Feign实现跨服务文件传输 434
12.4   分布式系统的稳定性保障—熔断器 437
12.4.1　熔断器的原理及实现案例 438
12.4.2　通过案例演示FallbackFactory对熔断批处理的支持 439
12.4.3　使用Hystrix Dashboard实现可视化仪表盘的监控案例 441
12.5   服务跟踪与路由网关的原理及实现案例 444
12.5.1　使用Spring Cloud Sleuth实现服务跟踪 444
12.5.2　使用路由网关Zuul实现请求映射 446
12.6   Spring Cloud技术栈补充介绍 449
12.6.1　分布式配置中心Spring Cloud Config 449
12.6.2　微服务通信Spring Cloud Bus 452
12.6.3　消息驱动微服务Spring Cloud Stream 454
   

第13章 通过案例讲解分布式服务框架Dubbo 455
13.1   Dubbo核心速览 456
13.2   动手开发基于Dubbo Zookeeper SSM Maven架构的分布式服务 456
         
 

第14章  MySQL性能调优案例实战 475
14.1   数据库的底层原理剖析 476
14.1.1　通过系统参数查看MySQL的各种性能指标 476
14.1.2　MySQL存储引擎结构与MyISAM性能优化 477
14.1.3　索引的数据结构 479
14.2   通过案例实战高性能系统的必备技术—SQL优化 480
14.2.1　通过案例详解SQL执行计划的十大参数 480
14.2.2　SQL优化案例演示 496
14.2.3　通过案例演示索引失效的4种常见场景 502
14.2.4　优化数据库性能的几点补充 506
14.2.5　定位拖累数据库性能的元凶—慢SQL排查与性能分析 508
14.3   各种类型的锁机制 514
 

第15章  基于海量数据的高性能高可用数据库方案的 设计与实现 517
            
15.1   使用MySQL及数据库中间件处理海量数据 518
15.1.1　设计基于MySQL MyCat Haproxy keepalived架构的数据 518          　
15.1.2　MySQL主从同步功能的设计与实现 519
15.1.3　实战基于MyCat的分库分表与读写分离功能 524
15.1.4　使用Haproxy实现MyCat的高可用 531
15.1.5　使用keepalived防止Haproxy单点故障 533
15.1.6　搭建高性能高可用低延迟的MySQL架构 537
15.2   搭建基于Oracle的分布式数据库 538
15.2.1　分布式数据库简介 538
15.2.2　分布式数据库的实现 539
 

第16章  使用Redis实现持久化与高速缓存功能 541
16.1   Redis实战精讲 542
16.1.1　Redis核心概念与环境搭建 542
16.1.2　Redis六大常见类型的核心操作 544
16.2   Redis配置文件与持久化实战 547
16.2.1　Redis配置文件的常见参数 547
16.2.2　RDB及AOF方式的持久化操作及灾难恢复实战 549
16.3   Redis事务操作演示案例 554
16.3.1　Redis事务的核心概念和操作演示 554
16.3.2　如何在Redis中使用事务监控 556
16.4   操作Redis的Java客户端—Jedis 556
16.4.1　使用Jedis操作Redis 556
16.4.2　在Jedis中通过ThreadLocal实现高并发访问 557
16.5   Redis高性能与高可用 564
16.5.1　Redis主从复制与读写分离案例 564
16.5.2　哨兵模式 567
16.6   使用Redis作为MySQL高速缓存 569
  

第17章 分布式计算框架MapReduce入门详解 571
17.1   零基础搭建Hadoop开发环境运行MapReduce程序 572
17.1.1　从零开始搭建CentOS 6集群环境 572
17.1.2　搭建CentOS 7集群环境 579
17.1.3　搭建基于CentOS的Hadoop集群环境并初步使用 581
17.2   图文详解MapReduce 588
17.2.1　内存区域与内存模型 588
17.2.2　通过Combiner及压缩手段优化MapReduce网络传输 594
17.2.3　图解MapReduce全流程中的各个细节 596
   

第18章  通过典型案例剖析MapReduce内部机制 601
18.1   实战MapReduce 七大经典问题及优化策略 602
18.2   使用MapReduce解决共同关注问题 634
 显示全部信息