第0章 读者与教师指南 1 　　0.1 本书概述 1 　　0.2 实例系统 1 　　0.3 读者和教师的路线图 2 　　0.4 互联网和网站资源 3 第一部分 背景知识 第1章 计算机系统概述 6 　　1.1 基本构成 6 　　1.2 微处理器的发展 7 　　1.3 指令的执行 8 　　1.4 中断 10 1.4.1 中断和指令周期 11 1.4.2 中断处理 12 1.4.3 多个中断 14 第0章  读者与教师指南	1　　0.1  本书概述	1　　0.2  实例系统	1　　0.3  读者和教师的路线图	2　　0.4  互联网和网站资源	3第一部分  背景知识第1章  计算机系统概述	6　　1.1  基本构成	6　　1.2  微处理器的发展	7　　1.3  指令的执行	8　　1.4  中断	101.4.1  中断和指令周期	111.4.2  中断处理	121.4.3  多个中断	14　　1.5  存储器的层次结构	15　　1.6  高速缓存	171.6.1  动机	181.6.2  高速缓存原理	181.6.3  高速缓存设计	19　　1.7  直接内存存取	20　　1.8  多处理器和多核计算机组织结构	21     1.8.1  对称多处理器	21     1.8.2  多核计算机	23　　1.9  推荐读物	23　　1.10 关键术语、复习题和习题	24     1.10.1  关键术语	24     1.10.2  复习题	24     1.10.3  习题	24　　附录1A  两级存储器的性能特征	26第2章  操作系统概述	31　　2.1  操作系统的目标和功能	312.1.1  作为用户/计算机接口的操作系统	31     2.1.2  作为资源管理器的操作系统	32     2.1.3  操作系统的易扩展性	33　　2.2  操作系统的发展史	34     2.2.1  串行处理	34     2.2.2  简单批处理系统	34     2.2.3  多道批处理系统	36     2.2.4  分时系统	38　　2.3  主要成就	402.3.1  进程	402.3.2  内存管理	422.3.3  信息保护和安全	432.3.4  调度和资源管理	44　　2.4  现代操作系统的特征	45　　2.5  容错性	472.5.1  基本概念	472.5.2  错误	482.5.3  操作系统机制	482.6  多处理器和多核操作系统设计考虑因素	492.6.1  对称多处理器操作系统设计考虑因素	49     2.6.2  多核操作系统设计考虑因素	49　　2.7  微软Windows系统简介	51     2.7.1  背景	51     2.7.2  体系结构	51     2.7.3  客户-服务器模型	53     2.7.4  线程和SMP	54     2.7.5  Windows对象	54　　2.8  传统的UNIX系统	55     2.8.1  历史	55     2.8.2  描述	56　　2.9  现代UNIX系统	57     2.9.1  System V Release 4（SVR4）	58     2.9.2  BSD	58     2.9.3  Solaris 10	58　　2.10 Linux操作系统	582.10.1  历史	582.10.2  模块结构	592.10.3  内核组件	60　　2.11 Android	622.11.1  Android软件体系结构	632.11.2  Android系统体系结构	642.11.3  活动	652.11.4  电源管理	65　　2.12 推荐读物和动画	66　　2.13 关键术语、复习题和习题	672.13.1  关键术语	672.13.2  复习题	672.13.3  习题	67第二部分  进程第3章  进程描述和控制	70　　3.1  什么是进程	703.1.1  背景	703.1.2  进程和进程控制块	71　　3.2  进程状态	723.2.1  两状态进程模型	733.2.2  进程的创建和终止	743.2.3  五状态模型	753.2.4  被挂起的进程	78　　3.3  进程描述	813.3.1  操作系统的控制结构	823.3.2  进程控制结构	82　　3.4  进程控制	863.4.1  执行模式	863.4.2  进程创建	873.4.3  进程切换	88　　3.5  操作系统的执行	903.5.1  无进程内核	903.5.2  在用户进程内运行	903.5.3  基于进程的操作系统	91　　3.6  UNIX SVR4进程管理	913.6.1  进程状态	923.6.2  进程描述	933.6.3  进程控制	94　　3.7  小结	95　　3.8  推荐读物和动画	95　　3.9  关键术语、复习题和习题	953.9.1  关键术语	953.9.2  复习题	963.9.3  习题	96第4章  线程	99　　4.1  进程和线程	994.1.1  多线程	994.1.2  线程的功能	102　　4.2  线程分类	1034.2.1  用户级和内核级线程	1034.2.2  其他方案	106　　4.3  多核和多线程	1074.3.1  多核系统上的软件性能	1074.3.2  应用示例：Valve游戏软件	109　　4.4  Windows 8的进程和线程管理	1104.4.1  Windows 8中的变化	1114.4.2  Windows进程	1114.4.3  进程对象和线程对象	1124.4.4  多线程	1134.4.5  线程状态	1134.4.6  对操作系统子系统的支持	114　　4.5  Solaris的线程和SMP管理	1144.5.1  多线程体系结构	1144.5.2  动机	1154.5.3  进程结构	1154.5.4  线程的执行	1164.5.5  把中断当作线程	117　　4.6  Linux的进程和线程管理	1184.6.1  Linux任务	1184.6.2  Linux线程	1194.6.3  Linux命名空间	120　　4.7  Android的进程和线程管理	1214.7.1  安卓应用	1214.7.2  活动	1214.7.3  进程和线程	122　　4.8  Mac OS X的GCD技术	123　　4.9  小结	124　　4.10 推荐读物	125　　4.11 关键术语、复习题和习题	1254.11.1  关键术语	1254.11.2  复习题	1254.11.3  习题	125第5章  并发性：互斥和同步	129　　5.1  并发的原理	1305.1.1  一个简单的例子	1305.1.2  竞争条件	1325.1.3  操作系统关注的问题	1325.1.4  进程的交互	1335.1.5  互斥的要求	135　　5.2  互斥：硬件的支持	1365.2.1  中断禁用	1365.2.2  专用机器指令	136　　5.3  信号量	1385.3.1  互斥	1415.3.2  生产者/消费者问题	1425.3.3  信号量的实现	146　　5.4  管程	1475.4.1  使用信号的管程	1475.4.2  使用通知和广播的管程	149　　5.5  消息传递	1515.5.1  同步	1515.5.2  寻址	1525.5.3  消息格式	1535.5.4  排队原则	1545.5.5  互斥	154　　5.6  读者/写者问题	1555.6.1  读者优先	1565.6.2  写者优先	156　　5.7  小结	158　　5.8  推荐读物和动画	159　　5.9  关键术语、复习题和习题	1605.9.1  关键术语	1605.9.2  复习题	1605.9.3  习题	160第6章  并发：死锁和饥饿	170　　6.1  死锁原理	1706.1.1  可重用资源	1736.1.2  可消耗资源	1746.1.3  资源分配图	1746.1.4  死锁的条件	175　　6.2  死锁预防	1766.2.1  互斥	1766.2.2  占有且等待	1766.2.3  不可抢占	1766.2.4  循环等待	177　　6.3  死锁避免	1776.3.1  进程启动拒绝	1776.3.2  资源分配拒绝	178　　6.4  死锁检测	1816.4.1  死锁检测算法	1816.4.2  恢复	182　　6.5  一种综合的死锁策略	182　　6.6  哲学家就餐问题	1836.6.1  基于信号量的解决方案	1836.6.2  基于管程的解决方案	184　　6.7  UNIX并发机制	1856.7.1  管道	1866.7.2  消息	1866.7.3  共享内存	1866.7.4  信号量	1866.7.5  信号	187　　6.8  Linux内核并发机制	1876.8.1  原子操作	1886.8.2  自旋锁	1896.8.3  信号量	1906.8.4  屏障	191　　6.9  Solaris线程同步原语	1926.9.1  互斥锁	1936.9.2  信号量	1936.9.3  多读者/单写者锁	1936.9.4  条件变量	193　　6.10 Windows 7的并发机制	1946.10.1  等待函数	1946.10.2  分派器对象	1946.10.3  临界区	1956.10.4  轻量级读写锁和条件变量	1956.10.5  锁无关同步机制	196　　6.11 Android进程间通信	196　　6.12 小结	197　　6.13 推荐读物和动画	197　　6.14 关键术语、复习题和习题	1986.14.1  关键术语	1986.14.2  复习题	1986.14.3  习题	198　　　　　　　　　　　　第三部分  内存　　第7章  内存管理	204　　7.1  内存管理的需求	2047.1.1  重定位	2047.1.2  保护	2057.1.3  共享	2057.1.4  逻辑组织	2057.1.5  物理组织	206　　7.2  内存分区	2067.2.1  固定分区	2077.2.2  动态分区	2087.2.3  伙伴系统	2107.2.4  重定位	212　　7.3  分页	212　　7.4  分段	215　　7.5  小结	216　　7.6  推荐读物和动画	216　　7.7  关键术语、复习题和习题	2167.7.1  关键术语	2167.7.2  复习题	2177.7.3  习题	217　　附录7A  加载和链接	219第8章  虚拟内存	223　　8.1  硬件和控制结构	2238.1.1  局部性和虚拟内存	2248.1.2  分页	2258.1.3  分段	2328.1.4  段页式	2328.1.5  保护和共享	233　　8.2  操作系统软件	2348.2.1  读取策略	2358.2.2  放置策略	2358.2.3  置换策略	2358.2.4  驻留集管理	2398.2.5  清除策略	2438.2.6  加载控制	244　　8.3  UNIX和Solaris内存管理	2458.3.1  分页系统	2458.3.2  内核内存分配器	247　　8.4  Linux内存管理	2498.4.1  虚拟内存	2498.4.2  内核内存分配	250　　8.5  Windows内存管理	2518.5.1  Windows虚拟地址映射	2518.5.2  Windows分页	2518.5.3  Windows 8交换	252　　8.6  Android内存管理	252　　8.7  小结	252　　8.8  推荐读物和动画	253　　8.9  关键术语、复习题和习题	2538.9.1  关键术语	2538.9.2  复习题	2548.9.3  习题	254第四部分  调度第9章  单处理器调度	258　　9.1  处理器调度的类型	2589.1.1  长程调度	2599.1.2  中程调度	2609.1.3  短程调度	260　　9.2  调度算法	2609.2.1  短程调度规则	2609.2.2  优先级的使用	2619.2.3  选择调度策略	2629.2.4  性能比较	2689.2.5  公平共享调度	272　　9.3  传统的UNIX调度	273　　9.4  小结	274　　9.5  推荐读物9 显示全部信息