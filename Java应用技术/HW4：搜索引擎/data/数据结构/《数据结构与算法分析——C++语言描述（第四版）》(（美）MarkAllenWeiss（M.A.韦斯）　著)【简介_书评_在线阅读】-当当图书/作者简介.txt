第1章 程序设计：综述 1 1.1 本书讨论的内容 1 1.2 数学知识复习 2 1.2.1 指数(exponent) 2 1.2.2 对数(logarithm) 2 1.2.3 级数(series) 3 1.2.4 模运算(modular arithmetic) 4 1.2.5 证明方法 5 1.3 递归简论 7 1.4 C 类 10 1.4.1 基本的class语法 10 1.4.2 构造函数的附加语法和访问 函数 11 1.4.3 接口与实现的分离 13 第1章  程序设计：综述 11.1  本书讨论的内容 11.2  数学知识复习 21.2.1  指数(exponent) 21.2.2  对数(logarithm) 21.2.3  级数(series) 31.2.4  模运算(modular arithmetic) 41.2.5  证明方法 51.3  递归简论 71.4  C  类 101.4.1  基本的class语法 101.4.2  构造函数的附加语法和访问      函数 111.4.3  接口与实现的分离 131.4.4  vector类和string类 161.5  C  细节 171.5.1  指针(pointer) 181.5.2  左值、右值和引用 191.5.3  参数传递 211.5.4  返回值传递 231.5.5  std::swap和std::move 251.5.6  五大函数：析构函数，拷贝构造      函数，移动构造函数，拷贝赋值      operator=，移动赋值operator= 261.5.7  C风格数组和字符串 301.6  模板 311.6.1  函数模板 311.6.2  类模板 321.6.3  Object、Comparable和一个      例子 331.6.4  函数对象 341.6.5  类模板的分离式编译 371.7  使用矩阵 371.7.1  数据成员、构造函数和基本访问      函数 381.7.2  operator[] 381.7.3  五大函数 39小结 39练习 39参考文献 41第2章  算法分析 422.1  数学基础 422.2  模型 442.3  要分析的问题 442.4  运行时间计算 472.4.1  一个简单的例子 472.4.2  一般法则 472.4.3  最大子序列和问题的求解 492.4.4  运行时间中的对数 542.4.5  最坏情形分析的局限性 57小结 58练习 58参考文献 63第3章  表、栈和队列 643.1  抽象数据类型(ADT) 643.2  表ADT 643.2.1  表的简单数组实现 653.2.2  简单链表 653.3  STL中的vector和list 673.3.1  迭代器 683.3.2  例子：对表使用erase 693.3.3  const_iterators 703.4  vector的实现 723.5  list的实现 763.6  栈ADT 863.6.1  栈模型 863.6.2  栈的实现 863.6.3  应用 873.7  队列ADT 933.7.1  队列模型 933.7.2  队列的数组实现 933.7.3  队列的应用 95小结 96练习 96第4章  树 1004.1  预备知识 1004.1.1  树的实现 1014.1.2  树的遍历及应用 1024.2  二叉树 1054.2.1  实现 1054.2.2  一个例子——表达式树 1054.3  查找树ADT——二叉查找树 1084.3.1  contains 1104.3.2  findMin和findMax 1114.3.3  insert 1124.3.4  remove 1134.3.5  析构函数和拷贝构造函数 1154.3.6  平均情况分析 1154.4  AVL树 1184.4.1  单旋转 1194.4.2  双旋转 1214.5  伸展树 1284.5.1  一个简单的想法(不能直接      使用) 1284.5.2  展开 1304.6  树的遍历 1344.7  B树 1354.8  标准库中的集合与映射 1404.8.1  集合(set) 1404.8.2  映射(map) 1414.8.3  set和map的实现 1424.8.4  使用多个映射(map)的例 142小结 147练习 147参考文献 153第5章  散列 1555.1  一般想法 1555.2  散列函数 1555.3  分离链接法 1575.4  不用链表的散列表 1615.4.1  线性探测法 1615.4.2  平方探测法 1635.4.3  双散列 1665.5  再散列 1675.6  标准库中的散列表 1695.7  以最坏情形O(1)访问的散列表 1705.7.1  完美散列 1705.7.2  杜鹃散列 1725.7.3  跳房子散列 1815.8  通用散列 1845.9  可扩散列 186小结 188练习 189参考文献 193第6章  优先队列(堆) 1966.1  模型 1966.2  一些简单的实现 1976.3  二叉堆 1976.3.1  结构性质 1976.3.2  堆序性质 1986.3.3  基本的堆操作 1996.3.4  其他的堆操作 2036.4  优先队列的应用 2066.4.1  选择问题 2066.4.2  事件模拟 2076.5  d堆 2086.6  左式堆 2096.6.1  左式堆的性质 2096.6.2  左式堆操作 2106.7  斜堆 2156.8  二项队列 2166.8.1  二项队列构建 2166.8.2  二项队列操作 2176.8.3  二项队列的实现 2196.9  标准库中的优先队列 224小结 225练习 225参考文献 229第7章  排序 2327.1  预备知识 2327.2  插入排序 2337.2.1  算法 2337.2.2  插入排序的STL实现 2337.2.3  插入排序的分析 2357.3  一些简单排序算法的下界 2357.4  希尔排序 2367.4.1  希尔排序的最坏情形分析 2377.5  堆排序 2397.5.1  堆排序的分析 2417.6  归并排序 2427.6.1  归并排序的分析 2457.7  快速排序 2477.7.1  选取枢纽元 2497.7.2  分割策略 2507.7.3  小数组 2527.7.4  实际的快速排序例程 2527.7.5  快速排序的分析 2547.7.6  选择问题的线性期望时间      算法 2567.8  排序算法的一般下界 2587.8.1  决策树 2587.9  选择问题的决策树下界 2607.10  对手下界(adversary lower       bounds) 2627.11  线性时间排序：桶式排序和      基数排序 2657.12  外部排序 2697.12.1  为什么需要一些新的算法 2697.12.2  外部排序模型 2697.12.3  简单算法 2697.12.4  多路合并 2707.12.5  多相合并 2717.12.6  替换选择 272小结 273练习题 273参考文献 278第8章  不相交集类 2818.1  等价关系 2818.2  动态等价性问题 2818.3  基本数据结构 2838.4  灵巧求并算法 2868.5  路径压缩 2888.6  按秩求并和路径压缩的最坏      情形 2898.6.1  缓慢增长的函数 2898.6.2  通过递归分解进行的分析 2908.6.3   一个O(M log*N)界 2958.6.4  一个O(Mα(M, N))界 2968.7  一个应用 297小结 299练习 299参考文献 301第9章  图论算法 3039.1  若干定义 3039.1.1  图的表示 3049.2  拓扑排序 3059.3  最短路径算法 3089.3.1  无权最短路径 3099.3.2  Dijkstra算法 3129.3.3  具有负边值的图 3179.3.4  无圈图 3189.3.5  所有顶点对间的最短路径 3209.3.6  最短路径的例 3209.4  网络流问题 3229.4.1  一个简单的最大流算法 3239.5  最小生成树 3269.5.1  Prim算法 3279.5.2  Kruskal算法 3299.6  深度优先搜索的应用 3309.6.1  无向图 3319.6.2  双连通性 3329.6.3  欧拉回路 3359.6.4  有向图 3389.6.5  查找强分支 3399.7  NP完全性介绍 3409.7.1  难与易 3419.7.2  NP类 3419.7.3  NP完全问题 342小结 344练习 344参考文献 350第10章  算法设计技巧 35310.1  贪婪算法 35310.1.1  一个简单的调度问题 35410.1.2  哈夫曼编码 35510.1.3  近似装箱问题 35910.2  分治算法 36610.2.1  分治算法的运行时间 36710.2.2  最近点问题 36910.2.3  选择问题 37110.2.4  一些算术问题的理论改进 37410.3  动态规划 37710.3.1  用表代替递归 37710.3.2  矩阵乘法的顺序安排 37910.3.3  最优二叉查找树 38210.3.4  所有点对最短路径 38410.4  随机化算法 38610.4.1  随机数发生器 38710.4.2  跳跃表 39210.4.3  素性测试 39310.5  回溯算法 3 显示全部信息