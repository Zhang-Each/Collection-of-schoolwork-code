第0章 序幕 1 0.1　第 一次尝试　1 0.2　不用类来实现　4 0.3　为什么用C 更简单　5 0.4　一个更大的例子　5 0.5　小结　6 第0章 序幕 10.1　第 一次尝试　10.2　不用类来实现　40.3　为什么用C  更简单　50.4　一个更大的例子　50.5　小结　6第　一篇 动 机第　1章 为什么我用C  　91.1　问题　91.2　历史背景　101.3　自动软件发布　101.4　进入C  　131.5　重复利用的软件　171.6　后记　18第　2章 为什么用C  工作　192.1　小项目的成功　192.2　抽象　212.3　机器应该为人服务　23第3章　生活在现实世界中　25第二篇　类和继承第4章　类设计者的核查表　31第5章　代理类　395.1　问题　395.2　经典解决方案　405.3　虚复制函数　415.4　定义代理类　425.5　小结　44第6章　句柄：第 一部分　456.1　问题　456.2　一个简单的类　466.3　绑定到句柄　476.4　获取对象　486.5　简单的实现　486.6　引用计数型句柄　496.7　写时复制　516.8　讨论　52第7章　句柄：第二部分　557.1　回顾　567.2　分离引用计数　577.3　对引用计数的抽象　587.4　存取函数和写时复制　617.5　讨论　61第8章　一个面向对象程序范例　638.1　问题描述　638.2　面向对象的解决方案　648.3　句柄类　678.4　扩展1：新操作　698.5　扩展2：增加新的节点类型　728.6　反思　73第9章　一个课堂练习的分析（上）　759.1　问题描述　759.2　接口设计　779.3　补遗　799.4　测试接口　809.5　策略　819.6　方案　819.7　图像的组合　859.8　小结　87第　10章 一个课堂练习的分析（下）　8910.1　策略　8910.2　体验设计的灵活性　10210.3　小结　105第　11章 什么时候不应当使用虚函数　10711.1　适用的情况　10711.2　不适用的情况　10811.3　析构函数很特殊　11311.4　小结　114第三篇　模 板第　12章 设计容器类　11712.1　包含什么　11712.2　复制容器意味着什么　11812.3　怎样获取容器的元素　12112.4　怎样区分读和写　12112.5　怎样处理容器的增长　12312.6　容器支持哪些操作　12412.7　怎样设想容器元素的类型　12412.8　容器和继承　12512.9　设计一个类似数组的类　126第　13章 访问容器中的元素　13113.1　模拟指针　13113.2　获取数据　13213.3　遗留问题　13513.4　指向const Array的Pointer　13913.5　有用的增强操作　140第　14章 迭代器　14514.1　完成Pointer类　14514.2　什么是迭代器　14814.3　删除元素　14914.4　删除容器　15014.5　其他设计考虑　15114.6　讨论　151第　15章 序列　15315.1　技术状况　15315.2　基本的传统观点　15415.3　增加一些额外操作　15915.4　使用范例　16215.5　再增加一些　16615.6　请你思考　167第　16章 作为接口的模板　16916.1　问题　16916.2　第 一个例子　17016.3　分离迭代方式　17016.4　遍历任意类型　17216.5　增加其他类型　17316.6　将存储技术抽象化　17416.7　实证　17716.8　小结　178第　17章 模板和泛型算法　17917.1　一个特例　18017.2　泛型化元素类型　18017.3　推迟计数　18117.4　地址独立性　18317.5　查找非数组　18417.6　讨论　185第　18章 泛型迭代器　18718.1　一个不同的算法　18718.2　需求的分类　18918.3　输入迭代器　19018.4　输出迭代器　19018.5　前向迭代器　19118.6　双向迭代器　19118.7　随机存取迭代器　19218.8　是继承吗　19318.9　性能　19318.10　小结　194第　19章 使用泛型迭代器　19519.1　迭代器类型　19619.2　虚拟序列　19619.3　输出流迭代器　19919.4　输入流迭代器　20019.5　讨论　204第　20章 迭代器配接器　20520.1　一个例子　20520.2　方向不对称性　20720.3　一致性和不对称性　20820.4　自动反向　20920.5　讨论　211第　21章 函数对象　21321.1　一个例子　21321.2　函数指针　21621.3　函数对象　21821.4　函数对象模板　21921.5　隐藏中间类型　22021.6　一种类型包罗万象　22121.7　实现　22221.8　讨论　224第　22章 函数配接器　22522.1　为什么是函数对象　22522.2　用于内建操作符的函数对象　22622.3　绑定者（Binders）　22722.4　更深入地探讨　22822.5　接口继承　22922.6　使用这些类　23022.7　讨论　231第四篇　库第　23章 日常使用的库　23523.1　问题　23523.2　理解问题：第 1部分　23723.3　实现：第 1部分　23723.4　理解问题：第 2部分　23923.5　实现：第 2部分　24023.6　讨论　242第　24章 一个库接口设计实例　24324.1　复杂问题　24424.2　优化接口　24524.3　温故知新　24624.4　编写代码　24724.5　小结　249第　25章 库设计就是语言设计　25125.1　字符串　25125.2　内存耗尽　25225.3　复制　25525.4　隐藏实现　25725.5　缺省构造函数　25925.6　其他操作　26025.7　子字符串　26225.8　小结　263第　26章 语言设计就是库设计　26526.1　抽象数据类型　26526.2　库和抽象数据类型　26626.3　内存分配　26926.4　按成员赋值（memberwise assignment）和初始化　27026.5　异常处理　27226.6　小结　272第五篇　技 术第　27章 自己跟踪自己的类　27527.1　设计一个跟踪类　27527.2　创建死代码　27827.3　生成对象的审计跟踪　27927.4　验证容器行为　28127.5　小结　286第　28章 在簇中分配对象　28728.1　问题　28728.2　设计方案　28728.3　实现　29028.4　加入继承　29228.5　小结　293第　29章 应用器、操纵器和函数对象　29529.1　问题　29529.2　一种解决方案　29729.3　另一种不同的解决方案　29829.4　多个参数　29929.5　一个例子　30129.6　简化　30229.7　思考　30329.8　历史记录、参考资料和致谢　304第30章　将应用程序库从输入输出中分离出来　30530.1　问题　30530.2　解决方案1：技巧加蛮力　30630.3　解决方案2：抽象输出　30730.4　解决方案3：技巧而无蛮力　30930.5　评论　311第六篇　总 结第31章　通过复杂性获取简单性　31531.1　世界是复杂的　31531.2　复杂性变得隐蔽　31631.3　计算机也是一样　31631.4　计算机解决实际问题　31731.5　类库和语言语义　31831.6　很难使事情变得容易　31931.7　抽象和接口　32031.8　复杂度的守恒　321第32章　说了Hello world后再做什么　32332.1　找当地的专家　32332.2　选一种工具包并适应它　32432.3　C的某些部分是必需的　32432.4　C的其他部分不是必需的　32532.5　给自己设一些问题　32732.6　小结　329附录　Koenig和Moo夫妇访谈　331 显示全部信息