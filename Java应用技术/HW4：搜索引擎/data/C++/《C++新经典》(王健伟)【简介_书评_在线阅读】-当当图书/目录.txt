第1部分C/C 语言概述 recursive_timed_mutex 17.12补充知识、线程池浅谈、数量谈与总结 17.12.1知识点补充 17.12.2浅谈线程池 17.12.3线程创建数量谈 17.12.4C 11多线程总结 第18章内存高级话题 18.1new、delete的进一步认识 18.1.1总述与回顾 18.1.2从new说起 18.2new内存分配细节探秘与重载类内operator new、delete 18.2.1new内存分配细节探秘 18.2.2重载类中的operator new和operator delete操作符 
第1部分C/C  语言概述

第1章C/C  语言

1.1C和C  语言的起源、特点、关系与讲解范畴

1.2C/C  语言的市场需求与就业需求分析

1.3再谈C/C  就业

1.4搭建语言开发环境

第2部分C语言

第2章数据类型、运算符与表达式

2.1常量、变量、整型、实型和字符型

2.1.1如何创建最基本的能运行的C程序

2.1.2C语言的数据类型

2.1.3常量和变量

2.1.4整型数据

2.1.5实型数据

2.1.6字符型数据

2.1.7字符串变量

2.1.8变量赋初值

2.1.9数值型数据之间的混合运算

2.2算术运算符和表达式

2.2.1C语言的运算符

2.2.2算术运算符和算术表达式

2.2.3运算符优先级问题

2.2.4强制类型转换运算符

2.2.5自增和自减运算符

2.3赋值运算符和逗号运算符

2.3.1赋值运算符和赋值表达式

2.3.2逗号运算符和逗号表达式

第3章程序的基本结构和语句

3.1C语言的语句和程序的基本结构

3.1.1语句的分类

3.1.2程序的三种基本结构

3.1.3赋值语句的特殊写法

3.2数据的输出与数据的输入

3.2.1数据的输出

3.2.2数据的输入

 

 

第4章逻辑运算和判断选择

4.1关系运算符、关系表达式与逻辑运算符、逻辑表达式

4.1.1关系运算符和关系表达式

4.1.2逻辑运算符和逻辑表达式

4.2if语句详解

4.2.1if语句的三种形式

4.2.2if语句的嵌套

4.3条件运算符和switch语句

4.3.1条件运算符

4.3.2switch语句

第5章循环控制

5.1循环控制语句简介与goto、while、do…while语句精解

5.1.1循环控制语句简介

5.1.2goto语句

5.1.3while语句

5.1.4do…while语句

5.2for语句精解

5.2.1for语句的一般形式

5.2.2for语句的主要说明

5.3循环的嵌套、比较与break语句、continue语句

5.3.1循环的嵌套

5.3.2几种循环语句的比较

5.3.3break语句和continue语句

第6章数组

6.1一维数组

6.1.1一维数组的一般形式

6.1.2一维数组元素的引用

6.1.3一维数组的初始化

6.2二维数组

6.2.1二维数组的一般形式

6.2.2二维数组元素的引用

6.2.3二维数组的初始化

6.3字符数组

6.3.1字符数组的定义

6.3.2字符数组的初始化

6.3.3字符串和字符串结束标记

6.3.4字符数组的输入/输出

6.3.5字符串处理函数

第7章函数

7.1函数的基本概念和定义

7.1.1函数的基本概念

7.1.2函数的定义和返回值

7.2函数调用方式和嵌套调用

7.2.1函数调用的一般形式

7.2.2函数调用的方式

7.2.3函数的嵌套调用

7.3函数递归调用精彩演绎

7.3.1函数递归调用的定义

7.3.2递归调用的出口

7.3.3递归的优缺点及是否必须用递归

7.3.4递归的实际运用简介

7.4数组作为函数参数

7.4.1数组元素作为函数实参

7.4.2数组名作为函数实参

7.4.3用多维数组作为函数实参

7.5局部变量和全局变量

7.5.1局部变量

7.5.2全局变量

7.6变量的存储和引用与内部和外部函数

7.6.1变量的存储类别

7.6.2局部变量的存储方式

7.6.3全局变量跨文件引用

7.6.4函数的跨文件调用

7.6.5static关键字用法总结

第8章编译预处理

8.1宏定义

8.1.1不带参数的宏定义

8.1.2带参数的宏定义

8.2文件包含和条件编译

8.2.1文件包含

8.2.2条件编译

第9章指针

9.1指针的基本概念详解

9.1.1前提知识

9.1.2地址的概念

9.1.3直接访问和间接访问

9.2变量的指针和指向变量的指针变量

9.2.1指针变量的定义

9.2.2指针变量的引用

9.2.3指针变量作为函数参数

9.3数组的指针和指向数组的指针变量

9.3.1指向数组元素的指针变量的定义和赋值

9.3.2通过指针引用数组元素

9.3.3数组名作为函数参数

9.3.4回顾二维数组和多维数组的概念

9.3.5指向多维数组的指针和指针变量探究

9.3.6指针数组和数组指针

9.3.7多维数组的指针作为函数参数

9.4字符串的指针和指向字符串的指针变量

9.4.1字符串表示形式

9.4.2字符串指针作为函数参数

9.4.3字符指针变量与字符数组

9.5函数指针和返回指针值的函数

9.5.1用函数指针变量调用函数

9.5.2把指向函数的指针变量作为函数参数

9.5.3返回指针值的函数

9.6指针数组、指针的指针与main函数参数

9.6.1指针数组概念回顾

9.6.2指向指针的指针

9.6.3指针数组作为main函数参数

9.7本章小结

第10章结构体与共用体

10.1结构体变量定义、引用与初始化

10.1.1结构体简介

10.1.2定义结构体类型变量的方法

10.1.3结构体类型变量的引用

10.1.4结构体变量的初始化

10.2结构体数组与结构体指针

10.2.1结构体数组

10.2.2结构体指针

10.2.3用指向结构体的指针作为函数参数

10.3共用体、枚举类型与typedef

10.3.1共用体

10.3.2枚举类型

10.3.3用typedef定义类型

第11章位运算

11.1位的概念和位运算符简介

11.1.1位的概念

11.1.2位运算符简介

11.2位运算的具体应用

第12章文件

12.1文件简介及文本、二进制文件区别

12.1.1文件简介

12.1.2文本文件和二进制文件区别详细解释

12.2文件的打开、关闭、读写与实战操练

12.2.1文件的打开

12.2.2文件的关闭

12.2.3文件的读写

12.2.4文件读写实战操练

12.3将结构体写入二进制文件再读出

12.3.1将结构体写入二进制文件

12.3.2从二进制文件中读出结构体数据

12.3.3文件使用方式中"rb"和"r"、"wb"和"w"的区别

第3部分C  语言

第13章C  基本语言

13.1语言特性、工程构成与可移植性

13.1.1语言特性： 过程式、对象式程序设计

13.1.2C  程序和项目文件构成谈

13.1.3编译型语言概念与可移植性问题

13.2命名空间简介与基本输入/输出精解

13.2.1命名空间简介

13.2.2基本输入/输出

13.3auto、头文件防卫、引用与常量

13.3.1局部变量和初始化

13.3.2auto关键字简介

13.3.3头文件防卫式声明

13.3.4引用

13.3.5常量

13.4范围for、new内存动态分配与nullptr

13.4.1范围for语句

13.4.2动态内存分配问题

13.4.3nullptr

13.5结构、权限修饰符与类简介

13.5.1结构回顾

13.5.2public和private权限修饰符

13.5.3类简介

13.5.4类的组织

13.6函数新特性、inline内联函数与const详解

13.6.1函数回顾与后置返回类型

13.6.2inline内联函数

13.6.3函数特殊写法总结

13.6.4const char *、char const *与char * const 三者的区别

13.6.5函数形参中带const

13.7string类型

13.7.1总述

13.7.2string类型简介

13.7.3定义和初始化string对象

13.7.4string对象上的常用操作

13.8vector类型

13.8.1vector类型简介

13.8.2定义和初始化vector对象

13.8.3vector对象上的操作

13.9迭代器精彩演绎、失效分析及弥补、实战

13.9.1迭代器简介

13.9.2容器的迭代器类型

13.9.3迭代器begin/end、反向迭代器rbegin/rend操作

13.9.4迭代器运算符

13.9.5const_iterator迭代器

13.9.6迭代器失效

13.9.7范例演示

13.10类型转换： static_cast、reinterpret_cast等

13.10.1隐式类型转换

13.10.2显式类型转换（强制类型转换）

13.10.3总结

第14章类

14.1成员函数、对象复制与私有成员

14.1.1总述

14.1.2类基础

14.1.3成员函数

14.1.4对象的复制

14.1.5私有成员

14.2构造函数详解、explicit与初始化列表

14.2.1称呼上的统一

14.2.2构造函数

14.2.3多个构造函数

14.2.4函数默认参数

14.2.5隐式转换和explicit

14.2.6构造函数初始化列表

14.3inline、const、mutable、this与static

14.3.1在类定义中实现成员函数inline

14.3.2成员函数末尾的const

14.3.3mutable

14.3.4返回自身对象的引用——this

14.3.5static成员

14.4类内初始化、默认构造函数、“=default;”和“=delete;”

14.4.1类相关非成员函数

14.4.2类内初始值

14.4.3const成员变量的初始化

14.4.4默认构造函数

14.4.5“=default;”和“=delete;”

14.5拷贝构造函数

14.6重载运算符、拷贝赋值运算符与析构函数

14.6.1重载运算符

14.6.2拷贝赋值运算符（赋值运算符）

14.6.3析构函数（释放函数）

14.6.4几个话题

14.7子类、调用顺序、访问等级与函数遮蔽

14.7.1子类概念

14.7.2子类对象定义时调用构造函数的顺序

14.7.3访问等级（public、protected与private）

14.7.4函数遮蔽

14.8父类指针、虚/纯虚函数、多态性与析构函数

14.8.1父类指针与子类指针

14.8.2虚函数

14.8.3多态性

14.8.4纯虚函数与抽象类

14.8.5父类的析构函数一般写成虚函数

14.9友元函数、友元类与友元成员函数

14.9.1友元函数

14.9.2友元类

14.9.3友元成员函数

14.10RTTI、dynamic_cast、typeid、typeinfo与虚函数表

14.10.1RTTI是什么

14.10.2dynamic_cast运算符

14.10.3typeid运算符

14.10.4type_info类

14.10.5RTTI与虚函数表

14.11基类与派生类关系的详细再探讨

14.11.1派生类对象模型简介

14.11.2派生类构造函数

14.11.3既当父类又当子类

14.11.4不想当基类的类

14.11.5静态类型与动态类型

14.11.6派生类向基类的隐式类型转换

14.11.7父类、子类之间的复制与赋值

14.12左值、右值、左值引用、右值引用与move

14.12.1左值和右值

14.12.2引用分类

14.12.3左值引用

14.12.4右值引用

14.12.5std::move函数

14.12.6左值、右值总结说明

14.13临时对象深入探讨、解析与提高性能手段

14.13.1临时对象的概念

14.13.2产生临时对象的情况和解决方案

14.14对象移动、移动构造函数与移动赋值运算符

14.14.1对象移动的概念

14.14.2移动构造函数和移动赋值运算符概念

14.14.3移动构造函数演示

14.14.4移动赋值运算符演示

14.14.5合成的移动操作

14.14.6总结

14.15继承的构造函数、多重继承、类型转换与虚继承

14.15.1继承的构造函数

14.15.2多重继承

14.15.3类型转换

14.15.4虚基类与虚继承（虚派生）

14.16类型转换构造函数、运算符与类成员指针

14.16.1类型转换构造函数

14.16.2类型转换运算符(类型转换函数)

14.16.3类型转换的二义性问题

14.16.4类成员函数指针

14.16.5类成员变量指针

第15章模板与泛型

15.1模板概念与函数模板的定义、调用

15.1.1模板概念

15.1.2函数模板的定义

15.1.3函数模板的调用

15.1.4非类型模板参数

15.2类模板概念与类模板的定义、使用

15.2.1类模板概念

15.2.2类模板的定义

15.2.3类模板的成员函数

15.2.4类模板名字的使用

15.2.5非类型模板参数的使用

15.3使用typename的场合、函数模板、默认模板参数与趣味写法分析

15.3.1typename的使用场合

15.3.2函数指针作为其他函数的参数

15.3.3函数模板趣味用法举例

15.3.4默认模板参数

15.4成员函数模板，模板显式实例化与声明

15.4.1普通类的成员函数模板

15.4.2类模板的成员函数模板

15.4.3模板显式实例化与声明

15.5using定义模板别名与显式指定模板参数

15.5.1using定义模板别名

15.5.2显式指定模板参数

15.6模板全特化与偏特化（局部特化）

15.6.1类模板特化

15.6.2函数模板特化

15.6.3模板特化版本放置位置建议

15.7可变参模板与模板模板参数

15.7.1可变参函数模板

15.7.2可变参类模板

15.7.3模板模板参数

第16章智能指针

16.1直接内存管理(new/delete)、创建新工程与观察内存泄漏

16.1.1直接内存管理(new/delete)

16.1.2创建新工程与观察内存泄漏

16.2new/delete探秘、智能指针总述与shared_ptr基础

16.2.1new/delete探秘

16.2.2智能指针总述

16.2.3shared_ptr基础

16.3shared_ptr常用操作、计数与自定义删除器等

16.3.1shared_ptr引用计数的增加和减少

16.3.2shared_ptr指针常用操作

16.4weak_ptr简介、weak_ptr常用操作与尺寸问题

16.4.1weak_ptr简介

16.4.2weak_ptr常用操作

16.4.3尺寸问题

16.5shared_ptr使用场景、陷阱、性能分析与使用建议

16.5.1std::shared_ptr使用场景

16.5.2std::shared_ptr使用陷阱分析

16.5.3性能说明

16.5.4补充说明和使用建议

16.6unique_ptr简介与常用操作

16.6.1unique_ptr简介

16.6.2unique_ptr常用操作

16.7返回unique_ptr、删除器与尺寸问题

16.7.1返回unique_ptr

16.7.2删除器

16.7.3尺寸问题

16.8智能指针总结

第17章并发与多线程

17.1基本概念和实现

17.1.1并发、进程、线程的基本概念和综述

17.1.2并发的实现方法

17.1.3C  11新标准线程库

17.2线程启动、结束与创建线程写法

17.2.1范例演示线程运行的开始和结束

17.2.2其他创建线程的写法

17.3线程传参详解、detach坑与成员函数作为线程函数

17.3.1传递临时对象作为线程参数

17.3.2临时对象作为线程参数继续讲

17.3.3传递类对象与智能指针作为线程参数

17.3.4用成员函数作为线程入口函数

17.4创建多个线程、数据共享问题分析与案例代码

17.4.1创建和等待多个线程

17.4.2数据共享问题分析

17.4.3共享数据的保护实战范例

17.5互斥量的概念、用法、死锁演示与解决详解

17.5.1互斥量的基本概念

17.5.2互斥量的用法

17.5.3死锁

17.6unique_lock详解

17.6.1unique_lock取代lock_guard

17.6.2unique_lock的第二个参数

17.6.3unique_lock的成员函数

17.6.4unique_lock所有权的传递

17.7单例设计模式共享数据分析、解决与call_once

17.7.1设计模式简单谈

17.7.2单例设计模式

17.7.3单例设计模式共享数据问题分析、解决

17.7.4std::call_once

17.8condition_variable、wait、notify_one与notify_all

17.8.1条件变量std::condition_variable、wait与notify_one

17.8.2上述代码深入思考

17.8.3notify_all

17.9async、future、packaged_task与promise

17.9.1std::async和std::future创建后台任务并返回值

17.9.2std::packaged_task

17.9.3std::promise

17.9.4小结

17.10future其他成员函数、shared_future与atomic

17.10.1std::future的其他成员函数

17.10.2续谈std::async的不确定性问题

17.10.3std::shared_future

17.10.4原子操作std::atomic

17.11Windows临界区与其他各种mutex互斥量

17.11.1Windows临界区

17.11.2多次进入临界区试验

17.11.3自动析构技术

17.11.4recursive_mutex递归的独占互斥量

17.11.5带超时的互斥量std::timed_mutex和std::
recursive_timed_mutex

17.12补充知识、线程池浅谈、数量谈与总结

17.12.1知识点补充

17.12.2浅谈线程池

17.12.3线程创建数量谈

17.12.4C  11多线程总结

第18章内存高级话题

18.1new、delete的进一步认识

18.1.1总述与回顾

18.1.2从new说起

18.2new内存分配细节探秘与重载类内operator new、delete

18.2.1new内存分配细节探秘

18.2.2重载类中的operator new和operator delete操作符

18.2.3重载类中的operator new［］和operator delete［］操作符

18.3内存池概念、代码实现和详细分析

18.3.1内存池的概念和实现原理简介

18.3.2针对一个类的内存池实现演示代码

18.3.3内存池代码后续说明

18.4嵌入式指针概念及范例、内存池改进版

18.4.1嵌入式指针

18.4.2内存池代码的改进

18.5重载全局new/delete、定位new及重载

18.5.1重载全局operator new和operator delete操作符

18.5.2定位new（placement new）

18.5.3多种版本的operator new重载

第19章STL标准模板库大局观

19.1STL总述、发展史、组成与数据结构谈

19.1.1几个概念与推荐书籍

19.1.2算法和数据结构谈

19.1.3STL发展史和各个版本

19.1.4标准库的使用说明

19.1.5STL的组成部分

19.2容器分类与array、vector容器精解

19.2.1容器的分类

19.2.2容器的说明和简单应用

19.3容器的说明和简单应用例续

19.3.1deque和stack

19.3.2queue

19.3.3list

19.3.4其他

19.4分配器简介、使用与工作原理说

19.4.1分配器简介

19.4.2分配器的使用

19.4.3其他的分配器与原理说

19.4.4自定义分配器

19.5迭代器的概念和分类

19.5.1迭代器基本概念

19.5.2迭代器的分类

19.6算法简介、内部处理与使用范例

19.6.1算法简介

19.6.2算法内部一些处理

19.6.3一些典型算法使用范例

19.7函数对象回顾、系统函数对象与范例

19.7.1函数对象/仿函数回顾

19.7.2标准库中定义的函数对象

19.7.3标准库中定义的函数对象范例

19.8适配器概念、分类、范例与总结

19.8.1适配器基本概念

19.8.2容器适配器

19.8.3算法适配器

19.8.4迭代器适配器

19.8.5总结

第20章高级话题与新标准

20.1函数调用运算符与function类模板

20.1.1学习C  的体会

20.1.2函数调用运算符

20.1.3不同调用对象的相同调用形式

20.1.4标准库function类型简介

20.1.5总结

20.2万能引用

20.2.1类型区别基本概念

20.2.2universal reference基本认识

20.2.3万能引用资格的剥夺与辨认

20.3理解函数模板类型推断与查看类型推断结果

20.3.1如何查看类型推断结果

20.3.2理解函数模板类型推断

20.4引用折叠、转发、完美转发与forward

20.4.1引用折叠规则

20.4.2转发与完美转发

20.4.3std::forward

20.4.4std::move和std::forward的区别

20.4.5再谈万能引用

20.5理解auto类型推断与auto应用场合

20.5.1auto类型常规推断

20.5.2auto类型针对数组和函数的推断

20.5.3auto类型std::initializer_list的特殊推断

20.5.4auto不适用场合举例

20.5.5auto适用场合举例

20.6详解decltype含义与decltype主要用途

20.6.1decltype含义和举例

20.6.2decltype主要用途

20.6.3总结

20.7可调用对象、std::function与std::bind

20.7.1可调用对象

20.7.2std::function可调用对象包装器

20.7.3std::bind绑定器

20.7.4总结

20.8lambda表达式与for_each、find_if简介

20.8.1用法简介

20.8.2捕获列表

20.8.3lambda表达式延迟调用易出错细节分析

20.8.4lambda表达式中的mutable

20.8.5lambda表达式的类型和存储

20.8.6lambda表达式再演示和优点总结

20.9lambda表达式捕获模式的陷阱分析和展示

20.9.1捕获列表中的&

20.9.2形参列表可以使用auto

20.9.3成员变量的捕获问题

20.9.4广义lambda捕获

20.9.5静态局部变量

20.10可变参数函数、initializer_list与省略号形参

20.10.1可变参数函数

20.10.2initializer_list（初始化列表）

20.10.3省略号形参

20.11萃取技术概念与范例等

20.11.1类型萃取简介

20.11.2类型萃取范例

20.11.3迭代器萃取简介

20.11.4总结

后记IT职业发展的未来之路
 显示全部信息